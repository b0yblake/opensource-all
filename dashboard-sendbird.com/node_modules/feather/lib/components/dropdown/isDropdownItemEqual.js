"use strict";require("core-js/modules/es.symbol.js");require("core-js/modules/es.symbol.description.js");require("core-js/modules/es.object.to-string.js");require("core-js/modules/es.symbol.iterator.js");require("core-js/modules/es.array.iterator.js");require("core-js/modules/es.string.iterator.js");require("core-js/modules/web.dom-collections.iterator.js");Object.defineProperty(exports, "__esModule", { value: true });exports.isDropdownItemEqual = void 0;require("core-js/modules/es.object.keys.js");function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}

var isObjectEqual = function isObjectEqual(a, b) {
  // Because typeof null === 'object', we have to handle this case separately.
  if (a == null || b == null) {
    return a === b;
  }

  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }

  return Object.keys(a).every(function (key) {
    if (_typeof(a[key]) !== _typeof(b[key])) {
      return false;
    }
    switch (_typeof(a[key])) {
      case 'function':
        // FIXME: it considers functions are always equal to avoid breaking changes, but we should fix this.
        return true;
      case 'object':
        return isObjectEqual(a[key], b[key]);
      default:
        return a[key] === b[key];}

  });
};

var isDropdownItemEqual = function isDropdownItemEqual(a, b) {
  if (_typeof(a) !== _typeof(b)) {
    return false;
  }

  if (a == null || b == null) {
    // Because typeof null === 'object', we have to handle this case separately.
    return a === b;
  }

  switch (_typeof(a)) {
    case 'object':
      return isObjectEqual(a, b);
    default:
      return a === b;}

};exports.isDropdownItemEqual = isDropdownItemEqual;