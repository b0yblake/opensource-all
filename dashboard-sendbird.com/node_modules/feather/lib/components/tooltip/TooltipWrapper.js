"use strict";function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}require("core-js/modules/es.symbol.js");require("core-js/modules/es.symbol.description.js");require("core-js/modules/es.object.to-string.js");require("core-js/modules/es.symbol.iterator.js");require("core-js/modules/es.array.iterator.js");require("core-js/modules/es.string.iterator.js");require("core-js/modules/web.dom-collections.iterator.js");require("core-js/modules/es.array.slice.js");require("core-js/modules/es.function.name.js");require("core-js/modules/es.array.from.js");require("core-js/modules/es.object.keys.js");require("core-js/modules/es.array.filter.js");require("core-js/modules/es.object.get-own-property-descriptor.js");require("core-js/modules/web.dom-collections.for-each.js");require("core-js/modules/es.object.get-own-property-descriptors.js");require("core-js/modules/es.weak-map.js");Object.defineProperty(exports, "__esModule", { value: true });exports.TooltipWrapper = exports.TooltipReference = void 0;require("core-js/modules/es.array.includes.js");require("core-js/modules/es.string.includes.js");var _react = _interopRequireWildcard(require("react"));










var _reactDom = _interopRequireDefault(require("react-dom"));
var _reactPopper = require("react-popper");
var _styledComponents = _interopRequireDefault(require("styled-components"));



var _types = require("./types");var _jsxRuntime = require("react/jsx-runtime");function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}function _objectWithoutProperties(source, excluded) {if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];}}return target;}function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);if (_i == null) return;var _arr = [];var _n = true;var _d = false;var _s, _e;try {for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}var

Direction;(function (Direction) {Direction[Direction["Top"] = 0] = "Top";Direction[Direction["Right"] = 1] = "Right";Direction[Direction["Bottom"] = 2] = "Bottom";Direction[Direction["Left"] = 3] = "Left";})(Direction || (Direction = {}));
















var defaultPopperModifiers = {
  preventOverflow: { enabled: true, boundariesElement: 'viewport' },
  offset: { offset: '0, 4' } };


var getDirection = function getDirection(ev, obj) {
  var _obj$getBoundingClien = obj.getBoundingClientRect(),left = _obj$getBoundingClien.left,top = _obj$getBoundingClien.top,width = _obj$getBoundingClien.width,height = _obj$getBoundingClien.height;
  var x = (ev.clientX - left - width / 2) * (width > height ? height / width : 1);
  var y = (ev.clientY - top - height / 2) * (height > width ? width / height : 1);

  // 0 = Top, 1 = Right, 2 = Bottom, 3 = Left
  var d = Math.round(Math.atan2(y, x) / 1.57079633 + 5) % 4;

  return d;
};

var getReverseDirection = function getReverseDirection(direction) {
  return (direction + 2) % 4;
};

var getPopperPlacementDirection = function getPopperPlacementDirection(placement) {
  if (placement.includes('top')) {
    return Direction.Top;
  }
  if (placement.includes('right')) {
    return Direction.Right;
  }
  if (placement.includes('bottom')) {
    return Direction.Bottom;
  }
  return Direction.Left;
};

var TooltipReference = _styledComponents.default.div.withConfig({ displayName: "TooltipWrapper__TooltipReference", componentId: "i2o6ss-0" })([""]);exports.TooltipReference = TooltipReference;

var TooltipWrapper = function TooltipWrapper(_ref)











{var _ref$trigger = _ref.trigger,trigger = _ref$trigger === void 0 ? _types.TooltipTrigger.Hover : _ref$trigger,_ref$closeOnClickOuts = _ref.closeOnClickOutside,closeOnClickOutside = _ref$closeOnClickOuts === void 0 ? true : _ref$closeOnClickOuts,popperProps = _ref.popperProps,className = _ref.className,target = _ref.target,_ref$placement = _ref.placement,placement = _ref$placement === void 0 ? 'bottom' : _ref$placement,tooltipRef = _ref.tooltipRef,content = _ref.content,portalId = _ref.portalId,disabled = _ref.disabled,_children = _ref.children;
  var _useState = (0, _react.useState)(false),_useState2 = _slicedToArray(_useState, 2),isPopperRendered = _useState2[0],setIsPopperRendered = _useState2[1];
  var referenceNodeRef = (0, _react.useRef)(null);
  var tooltipNodeRef = (0, _react.useRef)(null);
  var tooltipPlacementRef = (0, _react.useRef)();
  var scheduleUpdateRef = (0, _react.useRef)();

  (0, _react.useEffect)(function () {
    scheduleUpdateRef.current && scheduleUpdateRef.current();
  }, [content]);

  var showTooltip = (0, _react.useCallback)(function () {
    setIsPopperRendered(true);
  }, []);

  var hideTooltip = (0, _react.useCallback)(function () {
    setIsPopperRendered(false);
  }, []);

  (0, _react.useEffect)(function () {
    if (trigger === _types.TooltipTrigger.Click && closeOnClickOutside) {
      var clickOutsideEventListener = function clickOutsideEventListener(event) {
        if (event.target instanceof Node) {
          if (tooltipNodeRef.current == null || tooltipNodeRef.current.contains(event.target)) {
            return;
          }
          if (referenceNodeRef.current == null || referenceNodeRef.current.contains(event.target)) {
            return;
          }
          hideTooltip();
        }
      };
      document.addEventListener('mousedown', clickOutsideEventListener);
      return function () {
        document.removeEventListener('mousedown', clickOutsideEventListener);
      };
    }
  }, [closeOnClickOutside, hideTooltip, trigger]);

  (0, _react.useImperativeHandle)(tooltipRef, function () {
    return {
      show: showTooltip,
      hide: hideTooltip };

  });

  var onReferenceMouseEnter = function onReferenceMouseEnter() {
    if (trigger === _types.TooltipTrigger.Hover) {
      showTooltip();
    }
  };

  var onTooltipReferenceMouseLeave = (0, _react.useCallback)(
  function (event) {
    if (trigger !== _types.TooltipTrigger.Hover || tooltipNodeRef.current == null || referenceNodeRef.current == null) {
      return;
    }
    if (tooltipPlacementRef.current == null) {
      hideTooltip();
      return;
    }
    var tooltip = tooltipNodeRef.current;
    var reference = referenceNodeRef.current;
    var placement = tooltipPlacementRef.current;

    var placementDirection = getPopperPlacementDirection(placement);
    var eventDirection = getDirection(event, event.currentTarget);

    /**
     * Let's say the area between the reference and the tooltip "bridge".
     * If the event target is the reference, bridgeDirection equals with placementDirection.
     */
    var bridgeDirection =
    event.currentTarget === reference ? placementDirection : getReverseDirection(placementDirection);

    if (eventDirection !== bridgeDirection) {
      hideTooltip();
      return;
    }

    /**
     * If eventDirection equals to bridgeDirection, compare the event coordinates and check if it is on the bridge.
     * If the event happens outside of the bridge, hide the tooltip.
     */

    var tooltipRect = tooltip.getBoundingClientRect();
    var referenceRect = reference.getBoundingClientRect();

    if (bridgeDirection === Direction.Top || bridgeDirection === Direction.Bottom) {
      if (
      event.clientX <= Math.max(tooltipRect.left, referenceRect.left) ||
      event.clientX >= Math.min(tooltipRect.right, referenceRect.right))
      {
        hideTooltip();
      }
    } else {
      if (
      event.clientY <= Math.max(tooltipRect.top, referenceRect.top) ||
      event.clientY >= Math.min(tooltipRect.bottom, referenceRect.bottom))
      {
        hideTooltip();
      }
    }
  },
  [hideTooltip, trigger]);


  var onReferenceClick = function onReferenceClick() {
    if (trigger !== _types.TooltipTrigger.Click) {
      return;
    }

    if (!isPopperRendered) {
      showTooltip();
      return;
    }
    if (tooltipNodeRef.current) {
      if (tooltipNodeRef.current.style.visibility === 'hidden') {
        showTooltip();
      } else {
        hideTooltip();
      }
    }
  };

  var referenceWrapperAttributes = _objectSpread({
    className: className,
    onMouseEnter: onReferenceMouseEnter,
    onMouseLeave: onTooltipReferenceMouseLeave },
  trigger === _types.TooltipTrigger.Click ? { onClick: onReferenceClick, role: 'button' } : null);


  var _ref2 = popperProps || {},modifiers = _ref2.modifiers,restPopperProps = _objectWithoutProperties(_ref2, ["modifiers"]);

  var popper = (0, _react.useMemo)(
  function () {return /*#__PURE__*/(
      (0, _jsxRuntime.jsx)(_reactPopper.Popper, _objectSpread(_objectSpread({
        innerRef: function innerRef(node) {
          tooltipNodeRef.current = node;
        },
        positionFixed: true,
        placement: placement },
      restPopperProps), {}, {
        modifiers: _objectSpread(_objectSpread({}, defaultPopperModifiers), modifiers), children:

        function children(popperChildrenProps) {
          tooltipPlacementRef.current = popperChildrenProps.placement;
          scheduleUpdateRef.current = popperChildrenProps.scheduleUpdate;

          return disabled ? null : _children(_objectSpread(_objectSpread({}, popperChildrenProps), {}, { onTooltipReferenceMouseLeave: onTooltipReferenceMouseLeave }));
        } })));},


  [_children, modifiers, onTooltipReferenceMouseLeave, placement, restPopperProps, disabled]);


  var renderPopper = function renderPopper() {
    if (!portalId) {
      return popper;
    }

    var portalContainer = document.getElementById(portalId);
    return portalContainer && /*#__PURE__*/_reactDom.default.createPortal(popper, portalContainer);
  };

  return /*#__PURE__*/(
    (0, _jsxRuntime.jsxs)(_reactPopper.Manager, { children: [/*#__PURE__*/
      (0, _jsxRuntime.jsx)(_reactPopper.Reference, { innerRef: referenceNodeRef, children:
        function children(_ref3) {var ref = _ref3.ref;return /*#__PURE__*/(
            (0, _jsxRuntime.jsx)(TooltipReference, _objectSpread(_objectSpread({ "data-test-id": "TooltipReference", ref: ref }, referenceWrapperAttributes), {}, { children:
              target })));} }),



      isPopperRendered && renderPopper()] }));


};exports.TooltipWrapper = TooltipWrapper;