"use strict";require("core-js/modules/es.symbol.js");require("core-js/modules/es.symbol.description.js");require("core-js/modules/es.symbol.iterator.js");require("core-js/modules/es.array.iterator.js");require("core-js/modules/es.string.iterator.js");require("core-js/modules/web.dom-collections.iterator.js");require("core-js/modules/es.array.slice.js");require("core-js/modules/es.function.name.js");require("core-js/modules/es.array.from.js");require("core-js/modules/es.object.keys.js");require("core-js/modules/es.object.get-own-property-descriptor.js");require("core-js/modules/es.object.get-own-property-descriptors.js");Object.defineProperty(exports, "__esModule", { value: true });exports.ToastQueue = void 0;require("regenerator-runtime/runtime.js");require("core-js/modules/es.object.to-string.js");require("core-js/modules/es.promise.js");require("core-js/modules/es.array.concat.js");require("core-js/modules/es.array.filter.js");require("core-js/modules/es.number.constructor.js");require("core-js/modules/es.number.is-nan.js");require("core-js/modules/web.dom-collections.for-each.js");require("core-js/modules/es.object.values.js");require("core-js/modules/es.array.map.js");var _react = require("react");
var _reactDom = require("react-dom");
var _reactTransitionGroup = require("react-transition-group");
var _styledComponents = _interopRequireDefault(require("styled-components"));


var _zIndexes = require("../../../lib/zIndexes");

var _constants = require("./constants");
var _ToastComponent = require("./ToastComponent");var _jsxRuntime = require("react/jsx-runtime");function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);if (_i == null) return;var _arr = [];var _n = true;var _d = false;var _s, _e;try {for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}





var Container = _styledComponents.default.div.withConfig({ displayName: "ToastQueue__Container", componentId: "pu5n5a-0" })(["position:fixed;z-index:", ";left:24px;bottom:24px;.toast-container{width:", "px;position:relative;display:flex;flex-direction:column;align-items:flex-start;> *{position:absolute;bottom:0;}}.item-enter{opacity:0;transform:translateX(-100%);}.item-enter-active{opacity:1;transform:translateX(0);transition:", "ms ease-in;transition-property:opacity,transform;}.item-exit{opacity:1;}.item-exit-active{opacity:0;height:0;transition:", "ms ease-in;transition-property:opacity,height;}"],

_zIndexes.ZIndexes.toast,




_constants.maxWidth,



















_constants.transitionDuration,










_constants.transitionDuration);




var findElement = function findElement(
callback)

{var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { timeout: 1000, interval: 10 };
  return new Promise(function (resolve) {
    var timer = window.setInterval(function () {
      var target = callback();
      if (target) {
        window.clearInterval(timer);
        resolve(target);
      }
    }, options.interval);

    // clear interval after timeout
    window.setTimeout(function () {
      window.clearInterval(timer);
      resolve(null);
    }, options.timeout);
  });
};

var buildStyleAttribute = function buildStyleAttribute(_ref) {var translateY = _ref.translateY,transitionDuration = _ref.transitionDuration;return "transform: translateY(".concat(
  translateY, "px); transition-duration: ").concat(transitionDuration, "ms;");};



var ToastQueue = /*#__PURE__*/(0, _react.forwardRef)(function (props, ref) {
  var _useState = (0, _react.useState)([]),_useState2 = _slicedToArray(_useState, 2),toasts = _useState2[0],setToasts = _useState2[1];
  var toastElementRefs = (0, _react.useRef)({});
  var autoHideTimerRefs = (0, _react.useRef)({});

  var removeToast = (0, _react.useCallback)(function (id) {
    setToasts(function (toasts) {return toasts.filter(function (item) {return item.id !== id;});});
  }, []);

  /**
   * Returns the rendered component of a ToastQueueItem.
   *
   * @param item ToastQueueItem to render as component
   * @param renderOptions Set `renderOptions.prerender` true to measure the rendered component. The rendered DOM node
   * will have `data-prerender-height` and `data-prerender-layout` attributes. Set `renderOptions.layout` either `short`
   * or `tall` to preset the layout to avoid rerendering during animation.
   */
  var renderToast = function renderToast(_ref2)


  {var id = _ref2.id,status = _ref2.status,option = _ref2.option;var renderOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { prerender: false };
    var title = option.title,message = option.message,onClose = option.onClose,actions = option.actions,iconProps = option.iconProps;
    var prerender = renderOptions.prerender,layout = renderOptions.layout;

    return /*#__PURE__*/(
      (0, _jsxRuntime.jsx)(_ToastComponent.ToastComponent, {
        ref:
        prerender ?
        undefined :
        function (node) {
          toastElementRefs.current[id] = node;
        },

        status: status,
        iconProps: iconProps,
        title: title,
        message: message,
        actions: actions,
        onCloseButtonClick: function onCloseButtonClick() {
          removeToast(id);
          onClose === null || onClose === void 0 ? void 0 : onClose({ closedBy: 'default' });
        },
        onActionClick: function onActionClick(_ref3) {var _ref3$closeToastOnCli = _ref3.closeToastOnClick,closeToastOnClick = _ref3$closeToastOnCli === void 0 ? false : _ref3$closeToastOnCli;
          if (closeToastOnClick) {
            removeToast(id);
            onClose === null || onClose === void 0 ? void 0 : onClose({ closedBy: 'action' });
          }
        },
        prerender: prerender,
        layout: layout }));


  };

  (0, _react.useImperativeHandle)(ref, function () {return {
      addToast: function addToast(item) {
        // prerender a hidden Toast component to know its height and layout.
        var tempElement = document.createElement('div');
        tempElement.setAttribute('style', 'position: absolute; visibility: hidden;');
        document.body.appendChild(tempElement);

        (0, _reactDom.render)(renderToast(item, { prerender: true }), tempElement, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var element, height, layout;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (

                    findElement(function () {return tempElement.querySelector('[data-prerender-height]');}));case 2:element = _context.sent;

                  if (element) {
                    height = Number(element.dataset.prerenderHeight);
                    layout = element.dataset.prerenderLayout;
                    if (!Number.isNaN(height)) {
                      setToasts(function (toasts) {return [].concat(_toConsumableArray(toasts), [_objectSpread(_objectSpread({}, item), {}, { height: height, layout: layout })]);});
                    }
                  }

                  // clean up temp element
                  (0, _reactDom.unmountComponentAtNode)(tempElement);
                  document.body.removeChild(tempElement);case 6:case "end":return _context.stop();}}}, _callee);})));

      } };});


  (0, _react.useEffect)(function () {
    toasts.forEach(function (toast) {
      var id = toast.id,option = toast.option;
      var _option$autoHide = option.autoHide,autoHide = _option$autoHide === void 0 ? true : _option$autoHide,_option$autoHideDurat = option.autoHideDuration,autoHideDuration = _option$autoHideDurat === void 0 ? _constants.defaultAutoHideDuration : _option$autoHideDurat;

      if (!autoHide) {
        if (autoHideTimerRefs.current[id]) {
          window.clearTimeout(autoHideTimerRefs.current[id]);
        }
        return;
      }

      if (autoHideTimerRefs.current[id] == null) {
        autoHideTimerRefs.current[id] = window.setTimeout(function () {var _option$onClose;
          removeToast(id);
          option === null || option === void 0 ? void 0 : (_option$onClose = option.onClose) === null || _option$onClose === void 0 ? void 0 : _option$onClose.call(option, { closedBy: 'timeout' });
        }, autoHideDuration);
      }
    });
  }, [removeToast, toasts]);

  (0, _react.useEffect)(function () {
    return function () {
      // clear all timers on unmount
      // eslint-disable-next-line react-hooks/exhaustive-deps
      Object.values(autoHideTimerRefs.current).forEach(function (timerId) {
        window.clearTimeout(timerId);
      });
    };
  }, []);

  return /*#__PURE__*/(
    (0, _jsxRuntime.jsx)(Container, { children: /*#__PURE__*/
      (0, _jsxRuntime.jsx)(_reactTransitionGroup.TransitionGroup, { className: "toast-container", children:
        toasts.map(function (item) {
          return /*#__PURE__*/(
            (0, _jsxRuntime.jsx)(_reactTransitionGroup.Transition, {

              timeout: _constants.transitionDuration,
              onEnter: function onEnter(node) {
                node.classList.add('item-enter');

                toasts.
                filter(function (item) {return toastElementRefs.current[item.id] && toastElementRefs.current[item.id] !== node;}).
                reverse().
                reduce(function (bottom, item) {
                  var refNode = toastElementRefs.current[item.id];

                  // shift an existing toast upward quickly - to avoid overlapping with the new toast
                  refNode.setAttribute(
                  'style',
                  buildStyleAttribute({ translateY: -bottom, transitionDuration: _constants.transitionDuration / 2 }));


                  setTimeout(function () {
                    // restore the original transition duration
                    refNode.setAttribute('style', buildStyleAttribute({ translateY: -bottom, transitionDuration: _constants.transitionDuration }));
                  }, 0);

                  refNode.dataset.bottom = String(bottom);
                  return bottom + refNode.scrollHeight + _constants.toastSpacing;
                }, node.scrollHeight + _constants.toastSpacing);
              },
              onEntering: function onEntering(node) {
                node.classList.add('item-enter-active');
              },
              onExit: function onExit(node) {
                node.classList.add('item-exit');

                toasts.
                filter(function (item) {return toastElementRefs.current[item.id] && toastElementRefs.current[item.id] !== node;}).
                forEach(function (item) {
                  var refNode = toastElementRefs.current[item.id];

                  // move down the remaining toasts
                  var bottom = Number(refNode.dataset.bottom) - node.scrollHeight - _constants.toastSpacing;
                  refNode.setAttribute('style', buildStyleAttribute({ translateY: -bottom, transitionDuration: _constants.transitionDuration }));

                  refNode.dataset.bottom = String(bottom);
                });
              },
              onExiting: function onExiting(node) {
                node.classList.add('item-exit-active');
              }, children:

              renderToast(item, { layout: item.layout }) }, item.id));


        }) }) }));



});exports.ToastQueue = ToastQueue;