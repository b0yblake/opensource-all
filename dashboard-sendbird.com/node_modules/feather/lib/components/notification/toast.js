"use strict";require("core-js/modules/es.object.keys.js");require("core-js/modules/es.symbol.js");require("core-js/modules/es.array.filter.js");require("core-js/modules/es.object.get-own-property-descriptor.js");require("core-js/modules/es.object.get-own-property-descriptors.js");require("core-js/modules/es.symbol.description.js");require("core-js/modules/es.symbol.iterator.js");require("core-js/modules/es.array.iterator.js");require("core-js/modules/es.string.iterator.js");require("core-js/modules/web.dom-collections.iterator.js");require("core-js/modules/es.array.slice.js");require("core-js/modules/es.function.name.js");require("core-js/modules/es.array.from.js");Object.defineProperty(exports, "__esModule", { value: true });exports.toast = exports.ToastStatic = void 0;require("core-js/modules/es.object.to-string.js");require("core-js/modules/es.regexp.to-string.js");require("core-js/modules/es.promise.js");require("core-js/modules/web.dom-collections.for-each.js");require("core-js/modules/es.object.entries.js");var _reactDom = require("react-dom");

var _nonSecure = require("nanoid/non-secure");

var _cssVariables = _interopRequireDefault(require("../../../lib/theme/cssVariables"));









var _ToastQueue = require("./ToastQueue");var _jsxRuntime = require("react/jsx-runtime");function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);if (_i == null) return;var _arr = [];var _n = true;var _d = false;var _s, _e;try {for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _objectWithoutProperties(source, excluded) {if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];}}return target;}function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

var DEFAULT_TOAST_ROOT_ELEMENT_ID = 'feather-toast-root';

var createToastRootElement = function createToastRootElement() {var rootElementID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_TOAST_ROOT_ELEMENT_ID;
  var rootElement = document.createElement('div');

  rootElement.setAttribute('id', rootElementID);
  document.body.appendChild(rootElement);

  return rootElement;
};

var defaultIconDict = {
  error: { icon: 'error-filled', color: 'white', size: 20 },
  info: { icon: 'info-filled', color: 'white', size: 20 },
  success: { icon: 'success-filled', color: (0, _cssVariables.default)('bg-positive'), size: 20 },
  warning: { icon: 'warning-filled', color: (0, _cssVariables.default)('neutral-10'), size: 20 } };var


ToastStatic = /*#__PURE__*/function () {





  function ToastStatic() {var _this = this;var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { rootElementID: DEFAULT_TOAST_ROOT_ELEMENT_ID };_classCallCheck(this, ToastStatic);this.options = options;_defineProperty(this, "toastRootElement", null);_defineProperty(this, "toastQueueRef", null);_defineProperty(this, "iconDict", defaultIconDict);_defineProperty(this, "onRenderCallback", null);_defineProperty(this, "renderToastQueue",














































    function () {
      (0, _reactDom.render)( /*#__PURE__*/
      (0, _jsxRuntime.jsx)(_ToastQueue.ToastQueue, {
        ref: function (_ref) {function ref(_x) {return _ref.apply(this, arguments);}ref.toString = function () {return _ref.toString();};return ref;}(function (ref) {
          if (ref) {
            _this.toastQueueRef = ref;
            if (_this.onRenderCallback) {
              _this.onRenderCallback(ref);
              _this.onRenderCallback = null;
            }
          }
        }) }),

      _this.getRootElement());

    });_defineProperty(this, "showToast",

    function (status, option) {return (
        new Promise(function (resolve) {
          var addToast = function addToast(toastQueue) {
            var id = (0, _nonSecure.nanoid)();
            // custom iconProps would be merged to iconDict
            var overWrittenIconProps = _objectSpread(_objectSpread({}, _this.iconDict[status]), option.iconProps);
            toastQueue.addToast({
              id: id,
              status: status,
              option: _objectSpread(_objectSpread({}, option), {}, { iconProps: overWrittenIconProps }) });

            return resolve(id);
          };

          if (_this.toastQueueRef == null) {
            // render ToastQueue then add a toast
            _this.onRenderCallback = addToast;
            _this.renderToastQueue();
            return;
          }
          addToast(_this.toastQueueRef);
        }));});_defineProperty(this, "success",





    function (option) {return _this.showToast('success', option);});_defineProperty(this, "info",





    function (option) {return _this.showToast('info', option);});_defineProperty(this, "warning",





    function (option) {return _this.showToast('warning', option);});_defineProperty(this, "error",





    function (option) {return _this.showToast('error', option);});_defineProperty(this, "open",





    function (_ref2) {var status = _ref2.status,option = _objectWithoutProperties(_ref2, ["status"]);return _this.showToast(status, option);});_defineProperty(this, "unmount",




    function () {
      if (_this.toastRootElement) {
        (0, _reactDom.unmountComponentAtNode)(_this.toastRootElement);
        _this.toastQueueRef = null;
      }
    });this.options = options;this.toastRootElement = null;this.options.iconDict && this.setIconDictWithOptions(this.options.iconDict);if (typeof window === 'undefined') {// Note that window.document can be undefined on server-side rendered applications.
      this.toastRootElement = null;return;}}_createClass(ToastStatic, [{ key: "rootElementID", get: function get() {var _this$options$rootEle;return (_this$options$rootEle = this.options.rootElementID) !== null && _this$options$rootEle !== void 0 ? _this$options$rootEle : DEFAULT_TOAST_ROOT_ELEMENT_ID;}, set: function set(value) {if (this.options.rootElementID !== value) {this.unmount();this.toastRootElement = null;this.options.rootElementID = value || undefined;}} }, { key: "setIconDictWithOptions", value: function setIconDictWithOptions(newIconDict) {// custom iconDict would be merged to defaultIconDict
      var overWrittenIconDict = _objectSpread({}, this.iconDict);Object.entries(newIconDict).forEach(function (_ref3) {var _ref4 = _slicedToArray(_ref3, 2),status = _ref4[0],iconProps = _ref4[1];overWrittenIconDict[status] = _objectSpread(_objectSpread({}, overWrittenIconDict[status]), iconProps);});this.iconDict = overWrittenIconDict;} }, { key: "getRootElement", value: function getRootElement() {if (this.toastRootElement) {return this.toastRootElement;}var rootElement = document.getElementById(this.rootElementID);if (rootElement) {this.toastRootElement = rootElement;return rootElement;}this.toastRootElement = createToastRootElement(this.rootElementID);return this.toastRootElement;} }]);return ToastStatic;}();
/**
 * @var {ToastStatic} toast generated with default option
 */exports.ToastStatic = ToastStatic;
var toast = new ToastStatic();exports.toast = toast;