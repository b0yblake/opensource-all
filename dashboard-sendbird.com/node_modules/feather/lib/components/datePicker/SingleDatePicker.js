"use strict";require("core-js/modules/es.object.keys.js");require("core-js/modules/es.symbol.js");require("core-js/modules/es.array.filter.js");require("core-js/modules/es.object.get-own-property-descriptor.js");require("core-js/modules/web.dom-collections.for-each.js");require("core-js/modules/es.object.get-own-property-descriptors.js");Object.defineProperty(exports, "__esModule", { value: true });exports.SingleDatePicker = void 0;require("core-js/modules/es.regexp.exec.js");require("core-js/modules/es.string.search.js");var _react = require("react");
var _reactDates = require("react-dates");
require("react-dates/initialize");
var _reactPopper = require("react-popper");
var _styledComponents = _interopRequireDefault(require("styled-components"));

var _downshift = require("downshift");
var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _dropdown = require("../../../lib/components/dropdown");
var _elevation = require("../../../lib/elevation");
var _zIndexes = require("../../../lib/zIndexes");

var _constants = require("./constants");
var _getDayPickerControllerProps = require("./getDayPickerControllerProps");
var _ToggleText = require("./ToggleText");
var _useStylesheet = require("./useStylesheet");var _jsxRuntime = require("react/jsx-runtime");function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) {symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});}keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}
















var DayPickerWrapper = _styledComponents.default.div.withConfig({ displayName: "SingleDatePicker__DayPickerWrapper", componentId: "sc-12qi680-0" })(["position:absolute;border-radius:4px;", ";overflow:hidden;z-index:", ";background:white;"],


_elevation.elevation.popover,

_zIndexes.ZIndexes.dropdownMenu);



var isFirefoxOrSafari = function isFirefoxOrSafari() {
  try {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || navigator.userAgent.search(/firefox/i);
  } catch (e) {
    return false;
  }
};

var SingleDatePicker = function SingleDatePicker(_ref)













{var date = _ref.date,onChange = _ref.onChange,enableOutsideDays = _ref.enableOutsideDays,_ref$placement = _ref.placement,placement = _ref$placement === void 0 ? 'bottom-start' : _ref$placement,minDate = _ref.minDate,maxDate = _ref.maxDate,disabled = _ref.disabled,className = _ref.className,_ref$placeholder = _ref.placeholder,placeholder = _ref$placeholder === void 0 ? 'Select date' : _ref$placeholder,_ref$size = _ref.size,size = _ref$size === void 0 ? 'medium' : _ref$size,popperProps = _ref.popperProps,_ref$formatDate = _ref.formatDate,formatDate = _ref$formatDate === void 0 ? _constants.defaultDateFormatter : _ref$formatDate,timezone = _ref.timezone;
  var _useSelect = (0, _downshift.useSelect)({ items: [] }),getToggleButtonProps = _useSelect.getToggleButtonProps,isOpen = _useSelect.isOpen,toggleMenu = _useSelect.toggleMenu,closeMenu = _useSelect.closeMenu;
  var scheduleUpdateRef = (0, _react.useRef)();

  var handleBlockedDate = (0, _react.useCallback)(
  function (day) {
    return minDate && (0, _momentTimezone.default)(day).isBefore(minDate, 'date') || maxDate && (0, _momentTimezone.default)(day).isAfter(maxDate, 'date');
  },
  [minDate, maxDate]);


  (0, _react.useEffect)(function () {var _scheduleUpdateRef$cu;
    (_scheduleUpdateRef$cu = scheduleUpdateRef.current) === null || _scheduleUpdateRef$cu === void 0 ? void 0 : _scheduleUpdateRef$cu.call(scheduleUpdateRef);
  }, [date, size]);

  (0, _useStylesheet.useStylesheet)();

  /**
   * Event handlers to open a calendar when the picker is focused.
   *
   * Basically, we can call `toggleMenu()` inside focus event handler for this behavior.
   *
   * However in most browsers, focus event will be dispatched when a user clicks the picker, which will make
   * the calendar opened by Downshift on click closed by `toggleMenu()` in focus event handler.
   * Thus, we need to stop the default onclick behavior of Downshift.
   *
   * In addition, when the user clicks a focused picker, focus event won't be dispatched because it was
   * already focused. We need to handle that case manually in mousedown event handler to close the calendar.
   *
   * On the other hand on Safari, clicking a picker does not dispatch focus event. A focus event will be
   * dispatched only when it is focused using tab key. So we preserve the default onclick behavior of
   * Downshift on Safari, just adding the focus event handler.
   */
  var toggleButtonProps = getToggleButtonProps(_objectSpread({
    onFocus: function onFocus(event) {
      event.currentTarget.style.boxShadow = '';
      toggleMenu();
    },
    onMouseUp: function onMouseUp(event) {
      event.currentTarget.style.boxShadow = 'none';
    } },
  isFirefoxOrSafari() ?
  {
    onMouseDown: function onMouseDown(event) {
      event.currentTarget.style.boxShadow = '';
    } } :

  {
    onMouseDown: function onMouseDown(event) {
      event.currentTarget.style.boxShadow = '';
      if (document.activeElement === event.currentTarget) {
        // if the target is focused, onFocus won't be called. so we have to call toggleMenu here.
        toggleMenu();
      }
      // otherwise onFocus will be called calling toggleMenu inside it.
    },
    onClick: function onClick(event) {
      event.nativeEvent['preventDownshiftDefault'] = true;
    } }));



  return /*#__PURE__*/(
    (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, { children: /*#__PURE__*/
      (0, _jsxRuntime.jsxs)(_reactPopper.Manager, { children: [/*#__PURE__*/
        (0, _jsxRuntime.jsx)(_reactPopper.Reference, { innerRef: toggleButtonProps.ref, children:
          function children(_ref2) {var ref = _ref2.ref;
            return /*#__PURE__*/(
              (0, _jsxRuntime.jsx)(_dropdown.DropdownToggleButton, _objectSpread(_objectSpread({},
              toggleButtonProps), {}, {
                ref: ref,
                size: size,
                variant: _constants.dropdownVariant,
                disabled: disabled,
                className: className,
                isPlaceholder: date == null,
                "aria-pressed": isOpen, children: /*#__PURE__*/

                (0, _jsxRuntime.jsx)(_ToggleText.ToggleText, { size: size, children: date ? formatDate(date) : placeholder }) })));


          } }), /*#__PURE__*/


        (0, _jsxRuntime.jsx)(_reactPopper.Popper, _objectSpread(_objectSpread({ placement: placement }, popperProps), {}, { children:
          function children(_ref3) {var ref = _ref3.ref,style = _ref3.style,scheduleUpdate = _ref3.scheduleUpdate;
            scheduleUpdateRef.current = scheduleUpdate;
            return (
              isOpen && /*#__PURE__*/
              (0, _jsxRuntime.jsx)(DayPickerWrapper, {
                className: "Feather__SingleDatePicker",
                ref: ref,
                style: _objectSpread(_objectSpread({}, style), isOpen ? null : { opacity: 0, pointerEvents: 'none' }),
                onMouseUp: function onMouseUp(event) {
                  // prevent document mouseup event handler (which will close the date picker) from being called.
                  event.stopPropagation();
                }, children: /*#__PURE__*/

                (0, _jsxRuntime.jsx)(_reactDates.DayPickerSingleDateController, _objectSpread({
                  date: date,
                  onDateChange: onChange,
                  enableOutsideDays: enableOutsideDays,
                  isDayBlocked: handleBlockedDate,
                  numberOfMonths: 1,
                  onClose: function onClose() {
                    closeMenu();
                  } },
                (0, _getDayPickerControllerProps.getDayPickerControllerProps)(timezone))) }));




          } }))] }) }));




};exports.SingleDatePicker = SingleDatePicker;