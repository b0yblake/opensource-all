function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;

var __defNormalProp$1 = function __defNormalProp$1(obj, key, value) {
  return key in obj ? __defProp$1(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
  }) : obj[key] = value;
};

var __spreadValues$1 = function __spreadValues$1(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols$1) {
    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols$1(b)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prop = _step.value;
        if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return a;
};

var redux = function redux(reducer, initial) {
  return function (set, get, api) {
    api.dispatch = function (action) {
      set(function (state) {
        return reducer(state, action);
      }, false, action);
      return action;
    };

    api.dispatchFromDevtools = true;
    return __spreadValues$1({
      dispatch: function dispatch() {
        return api.dispatch.apply(api, arguments);
      }
    }, initial);
  };
};

function devtools(fn, options) {
  return function (set, get, api) {
    var didWarnAboutNameDeprecation = false;

    if (typeof options === "string" && !didWarnAboutNameDeprecation) {
      console.warn("[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead");
      didWarnAboutNameDeprecation = true;
    }

    var devtoolsOptions = options === void 0 ? {
      name: void 0,
      anonymousActionType: void 0
    } : typeof options === "string" ? {
      name: options
    } : options;
    var extensionConnector;

    try {
      extensionConnector = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
    } catch (_unused) {}

    if (!extensionConnector) {
      if (process.env.NODE_ENV === "development" && typeof window !== "undefined") {
        console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
      }

      return fn(set, get, api);
    }

    var extension = Object.create(extensionConnector.connect(devtoolsOptions));
    var didWarnAboutDevtools = false;
    Object.defineProperty(api, "devtools", {
      get: function get() {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }

        return extension;
      },
      set: function set(value) {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }

        extension = value;
      }
    });
    var didWarnAboutPrefix = false;
    Object.defineProperty(extension, "prefix", {
      get: function get() {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }

        return "";
      },
      set: function set() {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
      }
    });
    var isRecording = true;

    api.setState = function (state, replace, nameOrAction) {
      set(state, replace);
      if (!isRecording) return;
      extension.send(nameOrAction === void 0 ? {
        type: devtoolsOptions.anonymousActionType || "anonymous"
      } : typeof nameOrAction === "string" ? {
        type: nameOrAction
      } : nameOrAction, get());
    };

    var setStateFromDevtools = function setStateFromDevtools() {
      var originalIsRecording = isRecording;
      isRecording = false;
      set.apply(void 0, arguments);
      isRecording = originalIsRecording;
    };

    var initialState = fn(api.setState, get, api);
    extension.init(initialState);

    if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
      var didWarnAboutReservedActionType = false;
      var originalDispatch = api.dispatch;

      api.dispatch = function () {
        for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
          a[_key] = arguments[_key];
        }

        if (a[0].type === "__setState" && !didWarnAboutReservedActionType) {
          console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
          didWarnAboutReservedActionType = true;
        }

        originalDispatch.apply(void 0, a);
      };
    }

    extension.subscribe(function (message) {
      var _a;

      switch (message.type) {
        case "ACTION":
          if (typeof message.payload !== "string") {
            console.error("[zustand devtools middleware] Unsupported action format");
            return;
          }

          return parseJsonThen(message.payload, function (action) {
            if (action.type === "__setState") {
              setStateFromDevtools(action.state);
              return;
            }

            if (!api.dispatchFromDevtools) return;
            if (typeof api.dispatch !== "function") return;
            api.dispatch(action);
          });

        case "DISPATCH":
          switch (message.payload.type) {
            case "RESET":
              setStateFromDevtools(initialState);
              return extension.init(api.getState());

            case "COMMIT":
              return extension.init(api.getState());

            case "ROLLBACK":
              return parseJsonThen(message.state, function (state) {
                setStateFromDevtools(state);
                extension.init(api.getState());
              });

            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
              return parseJsonThen(message.state, function (state) {
                setStateFromDevtools(state);
              });

            case "IMPORT_STATE":
              {
                var nextLiftedState = message.payload.nextLiftedState;
                var lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
                if (!lastComputedState) return;
                setStateFromDevtools(lastComputedState);
                extension.send(null, nextLiftedState);
                return;
              }

            case "PAUSE_RECORDING":
              return isRecording = !isRecording;
          }

          return;
      }
    });
    return initialState;
  };
}

var parseJsonThen = function parseJsonThen(stringified, f) {
  var parsed;

  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error("[zustand devtools middleware] Could not parse the received json", e);
  }

  if (parsed !== void 0) f(parsed);
};

var subscribeWithSelector = function subscribeWithSelector(fn) {
  return function (set, get, api) {
    var origSubscribe = api.subscribe;

    api.subscribe = function (selector, optListener, options) {
      var listener = selector;

      if (optListener) {
        var equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
        var currentSlice = selector(api.getState());

        listener = function listener(state) {
          var nextSlice = selector(state);

          if (!equalityFn(currentSlice, nextSlice)) {
            var previousSlice = currentSlice;
            optListener(currentSlice = nextSlice, previousSlice);
          }
        };

        if (options == null ? void 0 : options.fireImmediately) {
          optListener(currentSlice, currentSlice);
        }
      }

      return origSubscribe(listener);
    };

    var initialState = fn(set, get, api);
    return initialState;
  };
};

var combine = function combine(initialState, create) {
  return function (set, get, api) {
    return Object.assign({}, initialState, create(set, get, api));
  };
};

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols(b)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var prop = _step2.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return a;
};

var toThenable = function toThenable(fn) {
  return function (input) {
    try {
      var result = fn(input);

      if (result instanceof Promise) {
        return result;
      }

      return {
        then(onFulfilled) {
          return toThenable(onFulfilled)(result);
        },

        catch(_onRejected) {
          return this;
        }

      };
    } catch (e) {
      return {
        then(_onFulfilled) {
          return this;
        },

        catch(onRejected) {
          return toThenable(onRejected)(e);
        }

      };
    }
  };
};

var persist = function persist(config, baseOptions) {
  return function (set, get, api) {
    var options = __spreadValues({
      getStorage: function getStorage() {
        return localStorage;
      },
      serialize: JSON.stringify,
      deserialize: JSON.parse,
      partialize: function partialize(state) {
        return state;
      },
      version: 0,
      merge: function merge(persistedState, currentState) {
        return __spreadValues(__spreadValues({}, currentState), persistedState);
      }
    }, baseOptions);

    if (options.blacklist || options.whitelist) {
      console.warn("The ".concat(options.blacklist ? "blacklist" : "whitelist", " option is deprecated and will be removed in the next version. Please use the 'partialize' option instead."));
    }

    var _hasHydrated = false;
    var hydrationListeners = /* @__PURE__ */new Set();
    var finishHydrationListeners = /* @__PURE__ */new Set();
    var storage;

    try {
      storage = options.getStorage();
    } catch (e) {}

    if (!storage) {
      return config(function () {
        console.warn("[zustand persist middleware] Unable to update item '".concat(options.name, "', the given storage is currently unavailable."));
        set.apply(void 0, arguments);
      }, get, api);
    } else if (!storage.removeItem) {
      console.warn("[zustand persist middleware] The given storage for item '".concat(options.name, "' does not contain a 'removeItem' method, which will be required in v4."));
    }

    var thenableSerialize = toThenable(options.serialize);

    var setItem = function setItem() {
      var state = options.partialize(__spreadValues({}, get()));

      if (options.whitelist) {
        Object.keys(state).forEach(function (key) {
          var _a;

          !((_a = options.whitelist) == null ? void 0 : _a.includes(key)) && delete state[key];
        });
      }

      if (options.blacklist) {
        options.blacklist.forEach(function (key) {
          return delete state[key];
        });
      }

      var errorInSync;
      var thenable = thenableSerialize({
        state,
        version: options.version
      }).then(function (serializedValue) {
        return storage.setItem(options.name, serializedValue);
      }).catch(function (e) {
        errorInSync = e;
      });

      if (errorInSync) {
        throw errorInSync;
      }

      return thenable;
    };

    var savedSetState = api.setState;

    api.setState = function (state, replace) {
      savedSetState(state, replace);
      void setItem();
    };

    var configResult = config(function () {
      set.apply(void 0, arguments);
      void setItem();
    }, get, api);
    var stateFromStorage;

    var hydrate = function hydrate() {
      var _a;

      if (!storage) return;
      _hasHydrated = false;
      hydrationListeners.forEach(function (cb) {
        return cb(get());
      });
      var postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then(function (storageValue) {
        if (storageValue) {
          return options.deserialize(storageValue);
        }
      }).then(function (deserializedStorageValue) {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
            }

            console.error("State loaded from storage couldn't be migrated since no migrate function was provided");
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then(function (migratedState) {
        stateFromStorage = options.merge(migratedState, configResult);
        set(stateFromStorage, true);
        return setItem();
      }).then(function () {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        _hasHydrated = true;
        finishHydrationListeners.forEach(function (cb) {
          return cb(stateFromStorage);
        });
      }).catch(function (e) {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };

    api.persist = {
      setOptions: function setOptions(newOptions) {
        options = __spreadValues(__spreadValues({}, options), newOptions);

        if (newOptions.getStorage) {
          storage = newOptions.getStorage();
        }
      },
      clearStorage: function clearStorage() {
        var _a;

        (_a = storage == null ? void 0 : storage.removeItem) == null ? void 0 : _a.call(storage, options.name);
      },
      rehydrate: function rehydrate() {
        return hydrate();
      },
      hasHydrated: function hasHydrated() {
        return _hasHydrated;
      },
      onHydrate: function onHydrate(cb) {
        hydrationListeners.add(cb);
        return function () {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: function onFinishHydration(cb) {
        finishHydrationListeners.add(cb);
        return function () {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    hydrate();
    return stateFromStorage || configResult;
  };
};

export { combine, devtools, persist, redux, subscribeWithSelector };