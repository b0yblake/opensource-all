import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { Vector3 } from '../math/Vector3.js';
import { Vector2 } from '../math/Vector2.js';
import { Box3 } from '../math/Box3.js';
import { EventDispatcher } from './EventDispatcher.js';
import { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';
import { Sphere } from '../math/Sphere.js';
import { Object3D } from './Object3D.js';
import { Matrix4 } from '../math/Matrix4.js';
import { Matrix3 } from '../math/Matrix3.js';
import * as MathUtils from '../math/MathUtils.js';
import { arrayMax } from '../utils.js';
var _id = 0;

var _m1 = /*@__PURE__*/new Matrix4();

var _obj = /*@__PURE__*/new Object3D();

var _offset = /*@__PURE__*/new Vector3();

var _box = /*@__PURE__*/new Box3();

var _boxMorphTargets = /*@__PURE__*/new Box3();

var _vector = /*@__PURE__*/new Vector3();

var BufferGeometry = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(BufferGeometry, _EventDispatcher);

  function BufferGeometry() {
    var _this;

    _this = _EventDispatcher.call(this) || this;
    Object.defineProperty(_assertThisInitialized(_this), 'id', {
      value: _id++
    });
    _this.uuid = MathUtils.generateUUID();
    _this.name = '';
    _this.type = 'BufferGeometry';
    _this.index = null;
    _this.attributes = {};
    _this.morphAttributes = {};
    _this.morphTargetsRelative = false;
    _this.groups = [];
    _this.boundingBox = null;
    _this.boundingSphere = null;
    _this.drawRange = {
      start: 0,
      count: Infinity
    };
    _this.userData = {};
    return _this;
  }

  var _proto = BufferGeometry.prototype;

  _proto.getIndex = function getIndex() {
    return this.index;
  };

  _proto.setIndex = function setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }

    return this;
  };

  _proto.getAttribute = function getAttribute(name) {
    return this.attributes[name];
  };

  _proto.setAttribute = function setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  };

  _proto.deleteAttribute = function deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  };

  _proto.hasAttribute = function hasAttribute(name) {
    return this.attributes[name] !== undefined;
  };

  _proto.addGroup = function addGroup(start, count, materialIndex) {
    if (materialIndex === void 0) {
      materialIndex = 0;
    }

    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  };

  _proto.clearGroups = function clearGroups() {
    this.groups = [];
  };

  _proto.setDrawRange = function setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  };

  _proto.applyMatrix4 = function applyMatrix4(matrix) {
    var position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    var normal = this.attributes.normal;

    if (normal !== undefined) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    var tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  };

  _proto.applyQuaternion = function applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);

    this.applyMatrix4(_m1);
    return this;
  };

  _proto.rotateX = function rotateX(angle) {
    // rotate geometry around world x-axis
    _m1.makeRotationX(angle);

    this.applyMatrix4(_m1);
    return this;
  };

  _proto.rotateY = function rotateY(angle) {
    // rotate geometry around world y-axis
    _m1.makeRotationY(angle);

    this.applyMatrix4(_m1);
    return this;
  };

  _proto.rotateZ = function rotateZ(angle) {
    // rotate geometry around world z-axis
    _m1.makeRotationZ(angle);

    this.applyMatrix4(_m1);
    return this;
  };

  _proto.translate = function translate(x, y, z) {
    // translate geometry
    _m1.makeTranslation(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  };

  _proto.scale = function scale(x, y, z) {
    // scale geometry
    _m1.makeScale(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  };

  _proto.lookAt = function lookAt(vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  };

  _proto.center = function center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  };

  _proto.setFromPoints = function setFromPoints(points) {
    var position = [];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  };

  _proto.computeBoundingBox = function computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    var position = this.attributes.position;
    var morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
          var morphAttribute = morphAttributesPosition[i];

          _box.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(this.boundingBox.min, _box.min);

            this.boundingBox.expandByPoint(_vector);

            _vector.addVectors(this.boundingBox.max, _box.max);

            this.boundingBox.expandByPoint(_vector);
          } else {
            this.boundingBox.expandByPoint(_box.min);
            this.boundingBox.expandByPoint(_box.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  };

  _proto.computeBoundingSphere = function computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    var position = this.attributes.position;
    var morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      var center = this.boundingSphere.center;

      _box.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
          var morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(_box.min, _boxMorphTargets.min);

            _box.expandByPoint(_vector);

            _vector.addVectors(_box.max, _boxMorphTargets.max);

            _box.expandByPoint(_vector);
          } else {
            _box.expandByPoint(_boxMorphTargets.min);

            _box.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      var maxRadiusSq = 0;

      for (var _i = 0, _il = position.count; _i < _il; _i++) {
        _vector.fromBufferAttribute(position, _i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (var _i2 = 0, _il2 = morphAttributesPosition.length; _i2 < _il2; _i2++) {
          var _morphAttribute = morphAttributesPosition[_i2];
          var morphTargetsRelative = this.morphTargetsRelative;

          for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
            _vector.fromBufferAttribute(_morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  };

  _proto.computeTangents = function computeTangents() {
    var index = this.index;
    var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }

    var indices = index.array;
    var positions = attributes.position.array;
    var normals = attributes.normal.array;
    var uvs = attributes.uv.array;
    var nVertices = positions.length / 3;

    if (attributes.tangent === undefined) {
      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    var tangents = attributes.tangent.array;
    var tan1 = [],
        tan2 = [];

    for (var i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }

    var vA = new Vector3(),
        vB = new Vector3(),
        vC = new Vector3(),
        uvA = new Vector2(),
        uvB = new Vector2(),
        uvC = new Vector2(),
        sdir = new Vector3(),
        tdir = new Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    var groups = this.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (var _i3 = 0, il = groups.length; _i3 < il; ++_i3) {
      var group = groups[_i3];
      var start = group.start;
      var count = group.count;

      for (var j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    var tmp = new Vector3(),
        tmp2 = new Vector3();
    var n = new Vector3(),
        n2 = new Vector3();

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      var t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      var test = tmp2.dot(tan2[v]);
      var w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (var _i4 = 0, _il3 = groups.length; _i4 < _il3; ++_i4) {
      var _group = groups[_i4];
      var _start = _group.start;
      var _count = _group.count;

      for (var _j = _start, _jl = _start + _count; _j < _jl; _j += 3) {
        handleVertex(indices[_j + 0]);
        handleVertex(indices[_j + 1]);
        handleVertex(indices[_j + 2]);
      }
    }
  };

  _proto.computeVertexNormals = function computeVertexNormals() {
    var index = this.index;
    var positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      var normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (var i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      var pA = new Vector3(),
          pB = new Vector3(),
          pC = new Vector3();
      var nA = new Vector3(),
          nB = new Vector3(),
          nC = new Vector3();
      var cb = new Vector3(),
          ab = new Vector3(); // indexed elements

      if (index) {
        for (var _i5 = 0, _il4 = index.count; _i5 < _il4; _i5 += 3) {
          var vA = index.getX(_i5 + 0);
          var vB = index.getX(_i5 + 1);
          var vC = index.getX(_i5 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (var _i6 = 0, _il5 = positionAttribute.count; _i6 < _il5; _i6 += 3) {
          pA.fromBufferAttribute(positionAttribute, _i6 + 0);
          pB.fromBufferAttribute(positionAttribute, _i6 + 1);
          pC.fromBufferAttribute(positionAttribute, _i6 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(_i6 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(_i6 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(_i6 + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  };

  _proto.merge = function merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    var attributes = this.attributes;

    for (var key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeOffset = attribute2.itemSize * offset;
      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

      for (var i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  };

  _proto.normalizeNormals = function normalizeNormals() {
    var normals = this.attributes.normal;

    for (var i = 0, il = normals.count; i < il; i++) {
      _vector.fromBufferAttribute(normals, i);

      _vector.normalize();

      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
  };

  _proto.toNonIndexed = function toNonIndexed() {
    function convertBufferAttribute(attribute, indices) {
      var array = attribute.array;
      var itemSize = attribute.itemSize;
      var normalized = attribute.normalized;
      var array2 = new array.constructor(indices.length * itemSize);
      var index = 0,
          index2 = 0;

      for (var i = 0, l = indices.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices[i] * itemSize;
        }

        for (var j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }

    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes; // attributes

    for (var name in attributes) {
      var attribute = attributes[name];
      var newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    var morphAttributes = this.morphAttributes;

    for (var _name in morphAttributes) {
      var morphArray = [];
      var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

      for (var i = 0, il = morphAttribute.length; i < il; i++) {
        var _attribute = morphAttribute[i];

        var _newAttribute = convertBufferAttribute(_attribute, indices);

        morphArray.push(_newAttribute);
      }

      geometry2.morphAttributes[_name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    var groups = this.groups;

    for (var _i7 = 0, l = groups.length; _i7 < l; _i7++) {
      var group = groups[_i7];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  };

  _proto.toJSON = function toJSON() {
    var data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      var parameters = this.parameters;

      for (var key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    } // for simplicity the code assumes attributes are not shared across geometries, see #15811


    data.data = {
      attributes: {}
    };
    var index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    var attributes = this.attributes;

    for (var _key in attributes) {
      var attribute = attributes[_key];
      data.data.attributes[_key] = attribute.toJSON(data.data);
    }

    var morphAttributes = {};
    var hasMorphAttributes = false;

    for (var _key2 in this.morphAttributes) {
      var attributeArray = this.morphAttributes[_key2];
      var array = [];

      for (var i = 0, il = attributeArray.length; i < il; i++) {
        var _attribute2 = attributeArray[i];
        array.push(_attribute2.toJSON(data.data));
      }

      if (array.length > 0) {
        morphAttributes[_key2] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    var groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    var boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  };

  _proto.clone = function clone() {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  };

  _proto.copy = function copy(source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    var data = {}; // name

    this.name = source.name; // index

    var index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    var attributes = source.attributes;

    for (var name in attributes) {
      var attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    var morphAttributes = source.morphAttributes;

    for (var _name2 in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

      for (var i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[_name2] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    var groups = source.groups;

    for (var _i8 = 0, _l = groups.length; _i8 < _l; _i8++) {
      var group = groups[_i8];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    var boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    var boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  };

  _proto.dispose = function dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  };

  return BufferGeometry;
}(EventDispatcher);

BufferGeometry.prototype.isBufferGeometry = true;
export { BufferGeometry };