import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { Quaternion } from '../math/Quaternion.js';
import { Vector3 } from '../math/Vector3.js';
import { Matrix4 } from '../math/Matrix4.js';
import { EventDispatcher } from './EventDispatcher.js';
import { Euler } from '../math/Euler.js';
import { Layers } from './Layers.js';
import { Matrix3 } from '../math/Matrix3.js';
import * as MathUtils from '../math/MathUtils.js';
var _object3DId = 0;

var _v1 = /*@__PURE__*/new Vector3();

var _q1 = /*@__PURE__*/new Quaternion();

var _m1 = /*@__PURE__*/new Matrix4();

var _target = /*@__PURE__*/new Vector3();

var _position = /*@__PURE__*/new Vector3();

var _scale = /*@__PURE__*/new Vector3();

var _quaternion = /*@__PURE__*/new Quaternion();

var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

var _addedEvent = {
  type: 'added'
};
var _removedEvent = {
  type: 'removed'
};

var Object3D = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(Object3D, _EventDispatcher);

  function Object3D() {
    var _this;

    _this = _EventDispatcher.call(this) || this;
    Object.defineProperty(_assertThisInitialized(_this), 'id', {
      value: _object3DId++
    });
    _this.uuid = MathUtils.generateUUID();
    _this.name = '';
    _this.type = 'Object3D';
    _this.parent = null;
    _this.children = [];
    _this.up = Object3D.DefaultUp.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(_assertThisInitialized(_this), {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    _this.matrix = new Matrix4();
    _this.matrixWorld = new Matrix4();
    _this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    _this.matrixWorldNeedsUpdate = false;
    _this.layers = new Layers();
    _this.visible = true;
    _this.castShadow = false;
    _this.receiveShadow = false;
    _this.frustumCulled = true;
    _this.renderOrder = 0;
    _this.animations = [];
    _this.userData = {};
    return _this;
  }

  var _proto = Object3D.prototype;

  _proto.onBeforeRender = function onBeforeRender() {};

  _proto.onAfterRender = function onAfterRender() {};

  _proto.applyMatrix4 = function applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  };

  _proto.applyQuaternion = function applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  };

  _proto.setRotationFromAxisAngle = function setRotationFromAxisAngle(axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  };

  _proto.setRotationFromEuler = function setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  };

  _proto.setRotationFromMatrix = function setRotationFromMatrix(m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  };

  _proto.setRotationFromQuaternion = function setRotationFromQuaternion(q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  };

  _proto.rotateOnAxis = function rotateOnAxis(axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  };

  _proto.rotateOnWorldAxis = function rotateOnWorldAxis(axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  };

  _proto.rotateX = function rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  };

  _proto.rotateY = function rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  };

  _proto.rotateZ = function rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  };

  _proto.translateOnAxis = function translateOnAxis(axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1.multiplyScalar(distance));
    return this;
  };

  _proto.translateX = function translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  };

  _proto.translateY = function translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  };

  _proto.translateZ = function translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  };

  _proto.localToWorld = function localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  };

  _proto.worldToLocal = function worldToLocal(vector) {
    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
  };

  _proto.lookAt = function lookAt(x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    var parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1.lookAt(_position, _target, this.up);
    } else {
      _m1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1);

    if (parent) {
      _m1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1);

      this.quaternion.premultiply(_q1.invert());
    }
  };

  _proto.add = function add(object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }

    return this;
  };

  _proto.remove = function remove(object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    var index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  };

  _proto.removeFromParent = function removeFromParent() {
    var parent = this.parent;

    if (parent !== null) {
      parent.remove(this);
    }

    return this;
  };

  _proto.clear = function clear() {
    for (var i = 0; i < this.children.length; i++) {
      var object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }

    this.children.length = 0;
    return this;
  };

  _proto.attach = function attach(object) {
    // adds object as a child of this, while maintaining the object's world transform
    this.updateWorldMatrix(true, false);

    _m1.copy(this.matrixWorld).invert();

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  };

  _proto.getObjectById = function getObjectById(id) {
    return this.getObjectByProperty('id', id);
  };

  _proto.getObjectByName = function getObjectByName(name) {
    return this.getObjectByProperty('name', name);
  };

  _proto.getObjectByProperty = function getObjectByProperty(name, value) {
    if (this[name] === value) return this;

    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      var object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  };

  _proto.getWorldPosition = function getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  };

  _proto.getWorldQuaternion = function getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  };

  _proto.getWorldScale = function getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion, target);
    return target;
  };

  _proto.getWorldDirection = function getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    var e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  };

  _proto.raycast = function raycast() {};

  _proto.traverse = function traverse(callback) {
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  };

  _proto.traverseVisible = function traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  };

  _proto.traverseAncestors = function traverseAncestors(callback) {
    var parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  };

  _proto.updateMatrix = function updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  };

  _proto.updateMatrixWorld = function updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  };

  _proto.updateWorldMatrix = function updateWorldMatrix(updateParents, updateChildren) {
    var parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  };

  _proto.toJSON = function toJSON(meta) {
    // meta is a string when called from JSON.stringify
    var isRootObject = meta === undefined || typeof meta === 'string';
    var output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }

      if (this.environment && this.environment.isTexture) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      var parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        var shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();

      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        var uuids = [];

        for (var _i = 0, _l = this.material.length; _i < _l; _i++) {
          uuids.push(serialize(meta.materials, this.material[_i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (var _i2 = 0; _i2 < this.children.length; _i2++) {
        object.children.push(this.children[_i2].toJSON(meta).object);
      }
    } //


    if (this.animations.length > 0) {
      object.animations = [];

      for (var _i3 = 0; _i3 < this.animations.length; _i3++) {
        var animation = this.animations[_i3];
        object.animations.push(serialize(meta.animations, animation));
      }
    }

    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);

      var _shapes = extractFromCache(meta.shapes);

      var skeletons = extractFromCache(meta.skeletons);
      var animations = extractFromCache(meta.animations);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (_shapes.length > 0) output.shapes = _shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      var values = [];

      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  };

  _proto.clone = function clone(recursive) {
    return new this.constructor().copy(this, recursive);
  };

  _proto.copy = function copy(source, recursive) {
    if (recursive === void 0) {
      recursive = true;
    }

    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  };

  return Object3D;
}(EventDispatcher);

Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
export { Object3D };