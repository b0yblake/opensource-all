import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { Vector2 } from '../math/Vector2.js';
import { Vector3 } from '../math/Vector3.js';

var RingGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(RingGeometry, _BufferGeometry);

  function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    var _this;

    if (innerRadius === void 0) {
      innerRadius = 0.5;
    }

    if (outerRadius === void 0) {
      outerRadius = 1;
    }

    if (thetaSegments === void 0) {
      thetaSegments = 8;
    }

    if (phiSegments === void 0) {
      phiSegments = 1;
    }

    if (thetaStart === void 0) {
      thetaStart = 0;
    }

    if (thetaLength === void 0) {
      thetaLength = Math.PI * 2;
    }

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'RingGeometry';
    _this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // some helper variables

    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2(); // generate vertices, normals and uvs

    for (var j = 0; j <= phiSegments; j++) {
      for (var i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside
        var segment = thetaStart + i / thetaSegments * thetaLength; // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, 0, 1); // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      } // increase the radius for next row of vertices


      radius += radiusStep;
    } // indices


    for (var _j = 0; _j < phiSegments; _j++) {
      var thetaSegmentLevel = _j * (thetaSegments + 1);

      for (var _i = 0; _i < thetaSegments; _i++) {
        var _segment = _i + thetaSegmentLevel;

        var a = _segment;
        var b = _segment + thetaSegments + 1;
        var c = _segment + thetaSegments + 2;
        var d = _segment + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this;
  }

  RingGeometry.fromJSON = function fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  };

  return RingGeometry;
}(BufferGeometry);

export { RingGeometry, RingGeometry as RingBufferGeometry };