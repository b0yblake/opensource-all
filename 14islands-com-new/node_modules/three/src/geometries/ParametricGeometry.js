import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { Vector3 } from '../math/Vector3.js';

var ParametricGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(ParametricGeometry, _BufferGeometry);

  function ParametricGeometry(func, slices, stacks) {
    var _this;

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'ParametricGeometry';
    _this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    }; // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var EPS = 0.00001;
    var normal = new Vector3();
    var p0 = new Vector3(),
        p1 = new Vector3();
    var pu = new Vector3(),
        pv = new Vector3();

    if (func.length < 3) {
      console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
    } // generate vertices, normals and uvs


    var sliceCount = slices + 1;

    for (var i = 0; i <= stacks; i++) {
      var v = i / stacks;

      for (var j = 0; j <= slices; j++) {
        var u = j / slices; // vertex

        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z); // normal
        // approximate tangent vectors via finite differences

        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }

        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        } // cross product of tangent vectors returns surface normal


        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u, v);
      }
    } // generate indices


    for (var _i = 0; _i < stacks; _i++) {
      for (var _j = 0; _j < slices; _j++) {
        var a = _i * sliceCount + _j;
        var b = _i * sliceCount + _j + 1;
        var c = (_i + 1) * sliceCount + _j + 1;
        var d = (_i + 1) * sliceCount + _j; // faces one and two

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this;
  }

  return ParametricGeometry;
}(BufferGeometry);

export { ParametricGeometry, ParametricGeometry as ParametricBufferGeometry };