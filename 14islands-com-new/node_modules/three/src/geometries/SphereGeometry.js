import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { Vector3 } from '../math/Vector3.js';

var SphereGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(SphereGeometry, _BufferGeometry);

  function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    var _this;

    if (radius === void 0) {
      radius = 1;
    }

    if (widthSegments === void 0) {
      widthSegments = 32;
    }

    if (heightSegments === void 0) {
      heightSegments = 16;
    }

    if (phiStart === void 0) {
      phiStart = 0;
    }

    if (phiLength === void 0) {
      phiLength = Math.PI * 2;
    }

    if (thetaStart === void 0) {
      thetaStart = 0;
    }

    if (thetaLength === void 0) {
      thetaLength = Math.PI;
    }

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'SphereGeometry';
    _this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    var index = 0;
    var grid = [];
    var vertex = new Vector3();
    var normal = new Vector3(); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // generate vertices, normals and uvs

    for (var iy = 0; iy <= heightSegments; iy++) {
      var verticesRow = [];
      var v = iy / heightSegments; // special case for the poles

      var uOffset = 0;

      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (var ix = 0; ix <= widthSegments; ix++) {
        var u = ix / widthSegments; // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    } // indices


    for (var _iy = 0; _iy < heightSegments; _iy++) {
      for (var _ix = 0; _ix < widthSegments; _ix++) {
        var a = grid[_iy][_ix + 1];
        var b = grid[_iy][_ix];
        var c = grid[_iy + 1][_ix];
        var d = grid[_iy + 1][_ix + 1];
        if (_iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (_iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this;
  }

  SphereGeometry.fromJSON = function fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  };

  return SphereGeometry;
}(BufferGeometry);

export { SphereGeometry, SphereGeometry as SphereBufferGeometry };