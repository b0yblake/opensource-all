import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { Vector3 } from '../math/Vector3.js';

var WireframeGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(WireframeGeometry, _BufferGeometry);

  function WireframeGeometry(geometry) {
    var _this;

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'WireframeGeometry';

    if (geometry.isGeometry === true) {
      console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      return _assertThisInitialized(_this);
    } // buffer


    var vertices = [];
    var edges = new Set(); // helper variables

    var start = new Vector3();
    var end = new Vector3();

    if (geometry.index !== null) {
      // indexed BufferGeometry
      var position = geometry.attributes.position;
      var indices = geometry.index;
      var groups = geometry.groups;

      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.count,
          materialIndex: 0
        }];
      } // create a data structure that contains all eges without duplicates


      for (var o = 0, ol = groups.length; o < ol; ++o) {
        var group = groups[o];
        var groupStart = group.start;
        var groupCount = group.count;

        for (var i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
          for (var j = 0; j < 3; j++) {
            var index1 = indices.getX(i + j);
            var index2 = indices.getX(i + (j + 1) % 3);
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);

            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
    } else {
      // non-indexed BufferGeometry
      var _position = geometry.attributes.position;

      for (var _i = 0, _l = _position.count / 3; _i < _l; _i++) {
        for (var _j = 0; _j < 3; _j++) {
          // three edges per triangle, an edge is represented as (index1, index2)
          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
          var _index = 3 * _i + _j;

          var _index2 = 3 * _i + (_j + 1) % 3;

          start.fromBufferAttribute(_position, _index);
          end.fromBufferAttribute(_position, _index2);

          if (isUniqueEdge(start, end, edges) === true) {
            vertices.push(start.x, start.y, start.z);
            vertices.push(end.x, end.y, end.z);
          }
        }
      }
    } // build geometry


    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    return _this;
  }

  return WireframeGeometry;
}(BufferGeometry);

function isUniqueEdge(start, end, edges) {
  var hash1 = start.x + "," + start.y + "," + start.z + "-" + end.x + "," + end.y + "," + end.z;
  var hash2 = end.x + "," + end.y + "," + end.z + "-" + start.x + "," + start.y + "," + start.z; // coincident edge

  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1, hash2);
    return true;
  }
}

export { WireframeGeometry };