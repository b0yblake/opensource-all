import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { ShapeUtils } from '../extras/ShapeUtils.js';

var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(ShapeGeometry, _BufferGeometry);

  function ShapeGeometry(shapes, curveSegments) {
    var _this;

    if (curveSegments === void 0) {
      curveSegments = 12;
    }

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'ShapeGeometry';
    _this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    }; // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var groupStart = 0;
    var groupCount = 0; // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (var i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);

        _this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support


        groupStart += groupCount;
        groupCount = 0;
      }
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions


    function addShape(shape) {
      var indexOffset = vertices.length / 3;
      var points = shape.extractPoints(curveSegments);
      var shapeVertices = points.shape;
      var shapeHoles = points.holes; // check direction of vertices

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (var _i = 0, l = shapeHoles.length; _i < l; _i++) {
        var shapeHole = shapeHoles[_i];

        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[_i] = shapeHole.reverse();
        }
      }

      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

      for (var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++) {
        var _shapeHole = shapeHoles[_i2];
        shapeVertices = shapeVertices.concat(_shapeHole);
      } // vertices, normals, uvs


      for (var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++) {
        var vertex = shapeVertices[_i3];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y); // world uvs
      } // incides


      for (var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++) {
        var face = faces[_i4];
        var a = face[0] + indexOffset;
        var b = face[1] + indexOffset;
        var c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }

    return _this;
  }

  var _proto = ShapeGeometry.prototype;

  _proto.toJSON = function toJSON() {
    var data = _BufferGeometry.prototype.toJSON.call(this);

    var shapes = this.parameters.shapes;
    return _toJSON(shapes, data);
  };

  ShapeGeometry.fromJSON = function fromJSON(data, shapes) {
    var geometryShapes = [];

    for (var j = 0, jl = data.shapes.length; j < jl; j++) {
      var shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }

    return new ShapeGeometry(geometryShapes, data.curveSegments);
  };

  return ShapeGeometry;
}(BufferGeometry);

function _toJSON(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}

export { ShapeGeometry, ShapeGeometry as ShapeBufferGeometry };