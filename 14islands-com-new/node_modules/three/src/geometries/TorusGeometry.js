import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { Vector3 } from '../math/Vector3.js';

var TorusGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(TorusGeometry, _BufferGeometry);

  function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    var _this;

    if (radius === void 0) {
      radius = 1;
    }

    if (tube === void 0) {
      tube = 0.4;
    }

    if (radialSegments === void 0) {
      radialSegments = 8;
    }

    if (tubularSegments === void 0) {
      tubularSegments = 6;
    }

    if (arc === void 0) {
      arc = Math.PI * 2;
    }

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'TorusGeometry';
    _this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3(); // generate vertices, normals and uvs

    for (var j = 0; j <= radialSegments; j++) {
      for (var i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2; // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (var _j = 1; _j <= radialSegments; _j++) {
      for (var _i = 1; _i <= tubularSegments; _i++) {
        // indices
        var a = (tubularSegments + 1) * _j + _i - 1;
        var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
        var c = (tubularSegments + 1) * (_j - 1) + _i;
        var d = (tubularSegments + 1) * _j + _i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this;
  }

  TorusGeometry.fromJSON = function fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  };

  return TorusGeometry;
}(BufferGeometry);

export { TorusGeometry, TorusGeometry as TorusBufferGeometry };