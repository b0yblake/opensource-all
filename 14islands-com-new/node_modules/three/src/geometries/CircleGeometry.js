import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { Vector3 } from '../math/Vector3.js';
import { Vector2 } from '../math/Vector2.js';

var CircleGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(CircleGeometry, _BufferGeometry);

  function CircleGeometry(radius, segments, thetaStart, thetaLength) {
    var _this;

    if (radius === void 0) {
      radius = 1;
    }

    if (segments === void 0) {
      segments = 8;
    }

    if (thetaStart === void 0) {
      thetaStart = 0;
    }

    if (thetaLength === void 0) {
      thetaLength = Math.PI * 2;
    }

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'CircleGeometry';
    _this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var vertex = new Vector3();
    var uv = new Vector2(); // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (var s = 0, i = 3; s <= segments; s++, i += 3) {
      var segment = thetaStart + s / segments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // indices


    for (var _i = 1; _i <= segments; _i++) {
      indices.push(_i, _i + 1, 0);
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this;
  }

  CircleGeometry.fromJSON = function fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  };

  return CircleGeometry;
}(BufferGeometry);

export { CircleGeometry, CircleGeometry as CircleBufferGeometry };