import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import { BufferGeometry } from '../core/BufferGeometry.js';
import { Vector3 } from '../math/Vector3.js';
import { Vector2 } from '../math/Vector2.js';
import * as MathUtils from '../math/MathUtils.js';

var LatheGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(LatheGeometry, _BufferGeometry);

  function LatheGeometry(points, segments, phiStart, phiLength) {
    var _this;

    if (segments === void 0) {
      segments = 12;
    }

    if (phiStart === void 0) {
      phiStart = 0;
    }

    if (phiLength === void 0) {
      phiLength = Math.PI * 2;
    }

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'LatheGeometry';
    _this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers

    var indices = [];
    var vertices = [];
    var uvs = []; // helper variables

    var inverseSegments = 1.0 / segments;
    var vertex = new Vector3();
    var uv = new Vector2(); // generate vertices and uvs

    for (var i = 0; i <= segments; i++) {
      var phi = phiStart + i * inverseSegments * phiLength;
      var sin = Math.sin(phi);
      var cos = Math.cos(phi);

      for (var j = 0; j <= points.length - 1; j++) {
        // vertex
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z); // uv

        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    } // indices


    for (var _i = 0; _i < segments; _i++) {
      for (var _j = 0; _j < points.length - 1; _j++) {
        var base = _j + _i * points.length;
        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this.setIndex(indices);

    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals


    _this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).


    if (phiLength === Math.PI * 2) {
      var normals = _this.attributes.normal.array;
      var n1 = new Vector3();
      var n2 = new Vector3();
      var n = new Vector3(); // this is the buffer offset for the last line of vertices

      var _base = segments * points.length * 3;

      for (var _i2 = 0, _j2 = 0; _i2 < points.length; _i2++, _j2 += 3) {
        // select the normal of the vertex in the first line
        n1.x = normals[_j2 + 0];
        n1.y = normals[_j2 + 1];
        n1.z = normals[_j2 + 2]; // select the normal of the vertex in the last line

        n2.x = normals[_base + _j2 + 0];
        n2.y = normals[_base + _j2 + 1];
        n2.z = normals[_base + _j2 + 2]; // average normals

        n.addVectors(n1, n2).normalize(); // assign the new values to both normals

        normals[_j2 + 0] = normals[_base + _j2 + 0] = n.x;
        normals[_j2 + 1] = normals[_base + _j2 + 1] = n.y;
        normals[_j2 + 2] = normals[_base + _j2 + 2] = n.z;
      }
    }

    return _this;
  }

  LatheGeometry.fromJSON = function fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  };

  return LatheGeometry;
}(BufferGeometry);

export { LatheGeometry, LatheGeometry as LatheBufferGeometry };