import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

import { BufferGeometry } from '../core/BufferGeometry.js';
import { Float32BufferAttribute } from '../core/BufferAttribute.js';
import * as Curves from '../extras/curves/Curves.js';
import { Vector2 } from '../math/Vector2.js';
import { Vector3 } from '../math/Vector3.js';
import { ShapeUtils } from '../extras/ShapeUtils.js';

var ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inheritsLoose(ExtrudeGeometry, _BufferGeometry);

  function ExtrudeGeometry(shapes, options) {
    var _this;

    _this = _BufferGeometry.call(this) || this;
    _this.type = 'ExtrudeGeometry';
    _this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];

    var scope = _assertThisInitialized(_this);

    var verticesArray = [];
    var uvArray = [];

    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      addShape(shape);
    } // build geometry


    _this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));

    _this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));

    _this.computeVertexNormals(); // functions


    function addShape(shape) {
      var placeholder = []; // options

      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var depth = options.depth !== undefined ? options.depth : 100;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var extrudePath = options.extrudePath;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

      if (options.amount !== undefined) {
        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
        depth = options.amount;
      } //


      var extrudePts,
          extrudeByPath = false;
      var splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion
        // SETUP TNB variables
        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      } // Safeguards if bevels are not enabled


      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      } // Variables initialization


      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (var h = 0, hl = holes.length; h < hl; h++) {
          var ahole = holes[h];

          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      var faces = ShapeUtils.triangulateShape(vertices, holes);
      /* Vertices */

      var contour = vertices; // vertices has all points but contour has only points of circumference

      for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
        var _ahole = holes[_h];
        vertices = vertices.concat(_ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return vec.clone().multiplyScalar(size).add(pt);
      }

      var vlen = vertices.length,
          flen = faces.length; // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.
        var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear
          // length of vectors for normalizing
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          var ptNextShift_x = inNext.x - v_next_y / v_next_len;
          var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes

          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges
          var direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      var contourMovements = [];

      for (var _i = 0, il = contour.length, j = il - 1, k = _i + 1; _i < il; _i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[_i] = getBevelVec(contour[_i], contour[j], contour[k]);
      }

      var holesMovements = [];
      var oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
        var _ahole2 = holes[_h2];
        oneHoleMovements = [];

        for (var _i2 = 0, _il = _ahole2.length, _j = _il - 1, _k = _i2 + 1; _i2 < _il; _i2++, _j++, _k++) {
          if (_j === _il) _j = 0;
          if (_k === _il) _k = 0; //  (j)---(i)---(k)

          oneHoleMovements[_i2] = getBevelVec(_ahole2[_i2], _ahole2[_j], _ahole2[_k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      } // Loop bevelSegments, 1 for the front, 1 for the back


      for (var b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {
        var t = b / bevelSegments;
        var z = bevelThickness * Math.cos(t * Math.PI / 2);

        var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape


        for (var _i3 = 0, _il2 = contour.length; _i3 < _il2; _i3++) {
          var vert = scalePt2(contour[_i3], contourMovements[_i3], _bs);
          v(vert.x, vert.y, -z);
        } // expand holes


        for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
          var _ahole3 = holes[_h3];
          oneHoleMovements = holesMovements[_h3];

          for (var _i4 = 0, _il3 = _ahole3.length; _i4 < _il3; _i4++) {
            var _vert = scalePt2(_ahole3[_i4], oneHoleMovements[_i4], _bs);

            v(_vert.x, _vert.y, -z);
          }
        }
      }

      var bs = bevelSize + bevelOffset; // Back facing vertices

      for (var _i5 = 0; _i5 < vlen; _i5++) {
        var _vert2 = bevelEnabled ? scalePt2(vertices[_i5], verticesMovements[_i5], bs) : vertices[_i5];

        if (!extrudeByPath) {
          v(_vert2.x, _vert2.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
          normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      } // Add stepped vertices...
      // Including front facing vertices


      for (var s = 1; s <= steps; s++) {
        for (var _i6 = 0; _i6 < vlen; _i6++) {
          var _vert3 = bevelEnabled ? scalePt2(vertices[_i6], verticesMovements[_i6], bs) : vertices[_i6];

          if (!extrudeByPath) {
            v(_vert3.x, _vert3.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
            normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      } // Add bevel segments planes
      //for ( b = 1; b <= bevelSegments; b ++ ) {


      for (var _b = bevelSegments - 1; _b >= 0; _b--) {
        var _t = _b / bevelSegments;

        var _z = bevelThickness * Math.cos(_t * Math.PI / 2);

        var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape


        for (var _i7 = 0, _il4 = contour.length; _i7 < _il4; _i7++) {
          var _vert4 = scalePt2(contour[_i7], contourMovements[_i7], _bs2);

          v(_vert4.x, _vert4.y, depth + _z);
        } // expand holes


        for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
          var _ahole4 = holes[_h4];
          oneHoleMovements = holesMovements[_h4];

          for (var _i8 = 0, _il5 = _ahole4.length; _i8 < _il5; _i8++) {
            var _vert5 = scalePt2(_ahole4[_i8], oneHoleMovements[_i8], _bs2);

            if (!extrudeByPath) {
              v(_vert5.x, _vert5.y, depth + _z);
            } else {
              v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z);
            }
          }
        }
      }
      /* Faces */
      // Top and bottom faces


      buildLidFaces(); // Sides faces

      buildSideFaces(); /////  Internal functions

      function buildLidFaces() {
        var start = verticesArray.length / 3;

        if (bevelEnabled) {
          var layer = 0; // steps + 1

          var offset = vlen * layer; // Bottom faces

          for (var _i9 = 0; _i9 < flen; _i9++) {
            var face = faces[_i9];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer; // Top faces

          for (var _i10 = 0; _i10 < flen; _i10++) {
            var _face = faces[_i10];
            f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
          }
        } else {
          // Bottom faces
          for (var _i11 = 0; _i11 < flen; _i11++) {
            var _face2 = faces[_i11];
            f3(_face2[2], _face2[1], _face2[0]);
          } // Top faces


          for (var _i12 = 0; _i12 < flen; _i12++) {
            var _face3 = faces[_i12];
            f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      } // Create faces for the z-sides of the shape


      function buildSideFaces() {
        var start = verticesArray.length / 3;
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
          var _ahole5 = holes[_h5];
          sidewalls(_ahole5, layeroffset); //, true

          layeroffset += _ahole5.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        var i = contour.length;

        while (--i >= 0) {
          var _j2 = i;

          var _k2 = i - 1;

          if (_k2 < 0) _k2 = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

          for (var _s = 0, sl = steps + bevelSegments * 2; _s < sl; _s++) {
            var slen1 = vlen * _s;
            var slen2 = vlen * (_s + 1);

            var a = layeroffset + _j2 + slen1,
                _b2 = layeroffset + _k2 + slen1,
                c = layeroffset + _k2 + slen2,
                d = layeroffset + _j2 + slen2;

            f4(a, _b2, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }

    return _this;
  }

  var _proto = ExtrudeGeometry.prototype;

  _proto.toJSON = function toJSON() {
    var data = _BufferGeometry.prototype.toJSON.call(this);

    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return _toJSON(shapes, options, data);
  };

  ExtrudeGeometry.fromJSON = function fromJSON(data, shapes) {
    var geometryShapes = [];

    for (var j = 0, jl = data.shapes.length; j < jl; j++) {
      var shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }

    var extrudePath = data.options.extrudePath;

    if (extrudePath !== undefined) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }

    return new ExtrudeGeometry(geometryShapes, data.options);
  };

  return ExtrudeGeometry;
}(BufferGeometry);

var WorldUVGenerator = {
  generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function _toJSON(shapes, options, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}

export { ExtrudeGeometry, ExtrudeGeometry as ExtrudeBufferGeometry };