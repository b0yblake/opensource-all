import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending, RGBAFormat } from '../constants.js';
import { Mesh } from '../objects/Mesh.js';
import { BoxGeometry } from '../geometries/BoxGeometry.js';
import { ShaderMaterial } from '../materials/ShaderMaterial.js';
import { cloneUniforms } from './shaders/UniformsUtils.js';
import { WebGLRenderTarget } from './WebGLRenderTarget.js';
import { CubeCamera } from '../cameras/CubeCamera.js';
import { CubeTexture } from '../textures/CubeTexture.js';

var WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
  _inheritsLoose(WebGLCubeRenderTarget, _WebGLRenderTarget);

  function WebGLCubeRenderTarget(size, options, dummy) {
    var _this;

    if (Number.isInteger(options)) {
      console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
      options = dummy;
    }

    _this = _WebGLRenderTarget.call(this, size, size, options) || this;
    options = options || {}; // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

    _this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    _this.texture.isRenderTargetTexture = true;
    _this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    _this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    _this.texture._needsFlipEnvMap = false;
    return _this;
  }

  var _proto = WebGLCubeRenderTarget.prototype;

  _proto.fromEquirectangularTexture = function fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat; // see #18859

    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    var shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader:
      /* glsl */
      "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
      fragmentShader:
      /* glsl */
      "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
    };
    var geometry = new BoxGeometry(5, 5, 5);
    var material = new ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    var mesh = new Mesh(geometry, material);
    var currentMinFilter = texture.minFilter; // Avoid blurred poles

    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    var camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  };

  _proto.clear = function clear(renderer, color, depth, stencil) {
    var currentRenderTarget = renderer.getRenderTarget();

    for (var i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }

    renderer.setRenderTarget(currentRenderTarget);
  };

  return WebGLCubeRenderTarget;
}(WebGLRenderTarget);

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
export { WebGLCubeRenderTarget };