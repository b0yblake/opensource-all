import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { ArrayCamera } from '../../cameras/ArrayCamera.js';
import { EventDispatcher } from '../../core/EventDispatcher.js';
import { PerspectiveCamera } from '../../cameras/PerspectiveCamera.js';
import { Vector3 } from '../../math/Vector3.js';
import { Vector4 } from '../../math/Vector4.js';
import { WebGLAnimation } from '../webgl/WebGLAnimation.js';
import { WebXRController } from './WebXRController.js';

var WebXRManager = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(WebXRManager, _EventDispatcher);

  function WebXRManager(renderer, gl) {
    var _this;

    _this = _EventDispatcher.call(this) || this;

    var scope = _assertThisInitialized(_this);

    var state = renderer.state;
    var session = null;
    var framebufferScaleFactor = 1.0;
    var referenceSpace = null;
    var referenceSpaceType = 'local-floor';
    var pose = null;
    var glBinding = null;
    var glFramebuffer = null;
    var glProjLayer = null;
    var glBaseLayer = null;
    var isMultisample = false;
    var glMultisampledFramebuffer = null;
    var glColorRenderbuffer = null;
    var glDepthRenderbuffer = null;
    var xrFrame = null;
    var depthStyle = null;
    var clearStyle = null;
    var controllers = [];
    var inputSourcesMap = new Map(); //

    var cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    var cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    var cameras = [cameraL, cameraR];
    var cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    var _currentDepthNear = null;
    var _currentDepthFar = null; //

    _this.cameraAutoUpdate = true;
    _this.enabled = false;
    _this.isPresenting = false;

    _this.getController = function (index) {
      var controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getTargetRaySpace();
    };

    _this.getControllerGrip = function (index) {
      var controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getGripSpace();
    };

    _this.getHand = function (index) {
      var controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getHandSpace();
    }; //


    function onSessionEvent(event) {
      var controller = inputSourcesMap.get(event.inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: event.type,
          data: event.inputSource
        });
      }
    }

    function onSessionEnd() {
      inputSourcesMap.forEach(function (controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null; // restore framebuffer/rendering state

      state.bindXRFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget());
      if (glFramebuffer) gl.deleteFramebuffer(glFramebuffer);
      if (glMultisampledFramebuffer) gl.deleteFramebuffer(glMultisampledFramebuffer);
      if (glColorRenderbuffer) gl.deleteRenderbuffer(glColorRenderbuffer);
      if (glDepthRenderbuffer) gl.deleteRenderbuffer(glDepthRenderbuffer);
      glFramebuffer = null;
      glMultisampledFramebuffer = null;
      glColorRenderbuffer = null;
      glDepthRenderbuffer = null;
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null; //

      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({
        type: 'sessionend'
      });
    }

    _this.setFramebufferScaleFactor = function (value) {
      framebufferScaleFactor = value;

      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
      }
    };

    _this.setReferenceSpaceType = function (value) {
      referenceSpaceType = value;

      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
      }
    };

    _this.getReferenceSpace = function () {
      return referenceSpace;
    };

    _this.getBaseLayer = function () {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };

    _this.getBinding = function () {
      return glBinding;
    };

    _this.getFrame = function () {
      return xrFrame;
    };

    _this.getSession = function () {
      return session;
    };

    _this.setSession = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {
        var attributes, layerInit, _layerInit, depthFormat, projectionlayerInit;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                session = value;

                if (!(session !== null)) {
                  _context.next = 22;
                  break;
                }

                session.addEventListener('select', onSessionEvent);
                session.addEventListener('selectstart', onSessionEvent);
                session.addEventListener('selectend', onSessionEvent);
                session.addEventListener('squeeze', onSessionEvent);
                session.addEventListener('squeezestart', onSessionEvent);
                session.addEventListener('squeezeend', onSessionEvent);
                session.addEventListener('end', onSessionEnd);
                session.addEventListener('inputsourceschange', onInputSourcesChange);
                attributes = gl.getContextAttributes();

                if (!(attributes.xrCompatible !== true)) {
                  _context.next = 14;
                  break;
                }

                _context.next = 14;
                return gl.makeXRCompatible();

              case 14:
                if (session.renderState.layers === undefined) {
                  layerInit = {
                    antialias: attributes.antialias,
                    alpha: attributes.alpha,
                    depth: attributes.depth,
                    stencil: attributes.stencil,
                    framebufferScaleFactor: framebufferScaleFactor
                  };
                  glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                  session.updateRenderState({
                    baseLayer: glBaseLayer
                  });
                } else if (gl instanceof WebGLRenderingContext) {
                  // Use old style webgl layer because we can't use MSAA
                  // WebGL2 support.
                  _layerInit = {
                    antialias: true,
                    alpha: attributes.alpha,
                    depth: attributes.depth,
                    stencil: attributes.stencil,
                    framebufferScaleFactor: framebufferScaleFactor
                  };
                  glBaseLayer = new XRWebGLLayer(session, gl, _layerInit);
                  session.updateRenderState({
                    layers: [glBaseLayer]
                  });
                } else {
                  isMultisample = attributes.antialias;
                  depthFormat = null;

                  if (attributes.depth) {
                    clearStyle = gl.DEPTH_BUFFER_BIT;
                    if (attributes.stencil) clearStyle |= gl.STENCIL_BUFFER_BIT;
                    depthStyle = attributes.stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                    depthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                  }

                  projectionlayerInit = {
                    colorFormat: attributes.alpha ? gl.RGBA8 : gl.RGB8,
                    depthFormat: depthFormat,
                    scaleFactor: framebufferScaleFactor
                  };
                  glBinding = new XRWebGLBinding(session, gl);
                  glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                  glFramebuffer = gl.createFramebuffer();
                  session.updateRenderState({
                    layers: [glProjLayer]
                  });

                  if (isMultisample) {
                    glMultisampledFramebuffer = gl.createFramebuffer();
                    glColorRenderbuffer = gl.createRenderbuffer();
                    gl.bindRenderbuffer(gl.RENDERBUFFER, glColorRenderbuffer);
                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.RGBA8, glProjLayer.textureWidth, glProjLayer.textureHeight);
                    state.bindFramebuffer(gl.FRAMEBUFFER, glMultisampledFramebuffer);
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, glColorRenderbuffer);
                    gl.bindRenderbuffer(gl.RENDERBUFFER, null);

                    if (depthFormat !== null) {
                      glDepthRenderbuffer = gl.createRenderbuffer();
                      gl.bindRenderbuffer(gl.RENDERBUFFER, glDepthRenderbuffer);
                      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, glDepthRenderbuffer);
                      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                    }

                    state.bindFramebuffer(gl.FRAMEBUFFER, null);
                  }
                }

                _context.next = 17;
                return session.requestReferenceSpace(referenceSpaceType);

              case 17:
                referenceSpace = _context.sent;
                animation.setContext(session);
                animation.start();
                scope.isPresenting = true;
                scope.dispatchEvent({
                  type: 'sessionstart'
                });

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    function onInputSourcesChange(event) {
      var inputSources = session.inputSources; // Assign inputSources to available controllers

      for (var i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      } // Notify disconnected


      for (var _i = 0; _i < event.removed.length; _i++) {
        var inputSource = event.removed[_i];
        var controller = inputSourcesMap.get(inputSource);

        if (controller) {
          controller.dispatchEvent({
            type: 'disconnected',
            data: inputSource
          });
          inputSourcesMap.delete(inputSource);
        }
      } // Notify connected


      for (var _i2 = 0; _i2 < event.added.length; _i2++) {
        var _inputSource = event.added[_i2];

        var _controller = inputSourcesMap.get(_inputSource);

        if (_controller) {
          _controller.dispatchEvent({
            type: 'connected',
            data: _inputSource
          });
        }
      }
    } //


    var cameraLPos = new Vector3();
    var cameraRPos = new Vector3();
    /**
     * Assumes 2 cameras that are parallel and share an X-axis, and that
     * the cameras' projection and world matrices have already been set.
     * And that near and far planes are identical for both cameras.
     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
     */

    function setProjectionFromUnion(camera, cameraL, cameraR) {
      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
      var ipd = cameraLPos.distanceTo(cameraRPos);
      var projL = cameraL.projectionMatrix.elements;
      var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
      // most likely identical top and bottom frustum extents.
      // Use the left camera for these values.

      var near = projL[14] / (projL[10] - 1);
      var far = projL[14] / (projL[10] + 1);
      var topFov = (projL[9] + 1) / projL[5];
      var bottomFov = (projL[9] - 1) / projL[5];
      var leftFov = (projL[8] - 1) / projL[0];
      var rightFov = (projR[8] + 1) / projR[0];
      var left = near * leftFov;
      var right = near * rightFov; // Calculate the new camera's position offset from the
      // left camera. xOffset should be roughly half `ipd`.

      var zOffset = ipd / (-leftFov + rightFov);
      var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
      // the values so that the near plane's position does not change in world space,
      // although must now be relative to the new union camera.

      var near2 = near + zOffset;
      var far2 = far + zOffset;
      var left2 = left - xOffset;
      var right2 = right + (ipd - xOffset);
      var top2 = topFov * far / far2 * near2;
      var bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }

    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }

      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }

    _this.updateCamera = function (camera) {
      if (session === null) return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;

      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        // Note that the new renderState won't apply until the next frame. See #18320
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }

      var parent = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);

      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      }

      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children

      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;

      for (var _i3 = 0, l = children.length; _i3 < l; _i3++) {
        children[_i3].updateMatrixWorld(true);
      } // update projection matrix for proper view frustum culling


      if (cameras.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        // assume single camera setup (AR)
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };

    _this.getCamera = function () {
      return cameraVR;
    };

    _this.getFoveation = function () {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }

      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }

      return undefined;
    };

    _this.setFoveation = function (foveation) {
      // 0 = no foveation = full resolution
      // 1 = maximum foveation = the edges render at lower resolution
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }

      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
        glBaseLayer.fixedFoveation = foveation;
      }
    }; // Animation Loop


    var onAnimationFrameCallback = null;

    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;

      if (pose !== null) {
        var views = pose.views;

        if (glBaseLayer !== null) {
          state.bindXRFramebuffer(glBaseLayer.framebuffer);
        }

        var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }

        for (var i = 0; i < views.length; i++) {
          var view = views[i];
          var viewport = null;

          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            var glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            state.bindXRFramebuffer(glFramebuffer);

            if (glSubImage.depthStencilTexture !== undefined) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, glSubImage.depthStencilTexture, 0);
            }

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
            viewport = glSubImage.viewport;
          }

          var camera = cameras[i];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }

          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }

        if (isMultisample) {
          state.bindXRFramebuffer(glMultisampledFramebuffer);
          if (clearStyle !== null) gl.clear(clearStyle);
        }
      } //


      var inputSources = session.inputSources;

      for (var _i4 = 0; _i4 < controllers.length; _i4++) {
        var controller = controllers[_i4];
        var inputSource = inputSources[_i4];
        controller.update(inputSource, frame, referenceSpace);
      }

      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);

      if (isMultisample) {
        var width = glProjLayer.textureWidth;
        var height = glProjLayer.textureHeight;
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, glMultisampledFramebuffer);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, glFramebuffer); // Invalidate the depth here to avoid flush of the depth data to main memory.

        gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [depthStyle]);
        gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, [depthStyle]);
        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST); // Invalidate the MSAA buffer because it's not needed anymore.

        gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        state.bindFramebuffer(gl.FRAMEBUFFER, glMultisampledFramebuffer);
      }

      xrFrame = null;
    }

    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);

    _this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
    };

    _this.dispose = function () {};

    return _this;
  }

  return WebXRManager;
}(EventDispatcher);

export { WebXRManager };