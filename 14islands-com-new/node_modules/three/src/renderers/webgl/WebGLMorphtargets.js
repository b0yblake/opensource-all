function numericalSort(a, b) {
  return a[0] - b[0];
}

function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);
  var workInfluences = [];

  for (var i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }

  function update(object, geometry, material, program) {
    var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    var length = objectInfluences === undefined ? 0 : objectInfluences.length;
    var influences = influencesList[geometry.id];

    if (influences === undefined || influences.length !== length) {
      // initialise list
      influences = [];

      for (var _i = 0; _i < length; _i++) {
        influences[_i] = [_i, 0];
      }

      influencesList[geometry.id] = influences;
    } // Collect influences


    for (var _i2 = 0; _i2 < length; _i2++) {
      var influence = influences[_i2];
      influence[0] = _i2;
      influence[1] = objectInfluences[_i2];
    }

    influences.sort(absNumericalSort);

    for (var _i3 = 0; _i3 < 8; _i3++) {
      if (_i3 < length && influences[_i3][1]) {
        workInfluences[_i3][0] = influences[_i3][0];
        workInfluences[_i3][1] = influences[_i3][1];
      } else {
        workInfluences[_i3][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[_i3][1] = 0;
      }
    }

    workInfluences.sort(numericalSort);
    var morphTargets = geometry.morphAttributes.position;
    var morphNormals = geometry.morphAttributes.normal;
    var morphInfluencesSum = 0;

    for (var _i4 = 0; _i4 < 8; _i4++) {
      var _influence = workInfluences[_i4];
      var index = _influence[0];
      var value = _influence[1];

      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== morphTargets[index]) {
          geometry.setAttribute('morphTarget' + _i4, morphTargets[index]);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== morphNormals[index]) {
          geometry.setAttribute('morphNormal' + _i4, morphNormals[index]);
        }

        morphInfluences[_i4] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute('morphTarget' + _i4) === true) {
          geometry.deleteAttribute('morphTarget' + _i4);
        }

        if (morphNormals && geometry.hasAttribute('morphNormal' + _i4) === true) {
          geometry.deleteAttribute('morphNormal' + _i4);
        }

        morphInfluences[_i4] = 0;
      }
    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
    // This allows us to switch between absolute morphs and relative morphs without changing shader code
    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


    var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}

export { WebGLMorphtargets };