import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';
import { arrayMax } from '../../utils.js';

function WebGLGeometries(gl, attributes, info, bindingStates) {
  var geometries = {};
  var wireframeAttributes = new WeakMap();

  function onGeometryDispose(event) {
    var geometry = event.target;

    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }

    for (var name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    var attribute = wireframeAttributes.get(geometry);

    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }

    bindingStates.releaseStatesOfGeometry(geometry);

    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener('dispose', onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }

  function update(geometry) {
    var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    } // morph targets


    var morphAttributes = geometry.morphAttributes;

    for (var _name in morphAttributes) {
      var array = morphAttributes[_name];

      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }

  function updateWireframeAttribute(geometry) {
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryPosition = geometry.attributes.position;
    var version = 0;

    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      version = geometryIndex.version;

      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var _array = geometryPosition.array;
      version = geometryPosition.version;

      for (var _i = 0, _l = _array.length / 3 - 1; _i < _l; _i += 3) {
        var _a = _i + 0;

        var _b = _i + 1;

        var _c = _i + 2;

        indices.push(_a, _b, _b, _c, _c, _a);
      }
    }

    var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
    //

    var previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute); //

    wireframeAttributes.set(geometry, attribute);
  }

  function getWireframeAttribute(geometry) {
    var currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      var geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}

export { WebGLGeometries };