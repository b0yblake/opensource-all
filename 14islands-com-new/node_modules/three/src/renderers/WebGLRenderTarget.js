import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { EventDispatcher } from '../core/EventDispatcher.js';
import { Texture } from '../textures/Texture.js';
import { LinearFilter } from '../constants.js';
import { Vector4 } from '../math/Vector4.js';
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

var WebGLRenderTarget = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(WebGLRenderTarget, _EventDispatcher);

  function WebGLRenderTarget(width, height, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _EventDispatcher.call(this) || this;
    _this.width = width;
    _this.height = height;
    _this.depth = 1;
    _this.scissor = new Vector4(0, 0, width, height);
    _this.scissorTest = false;
    _this.viewport = new Vector4(0, 0, width, height);
    _this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    _this.texture.isRenderTargetTexture = true;
    _this.texture.image = {
      width: width,
      height: height,
      depth: 1
    };
    _this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    _this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
    _this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    _this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    _this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
    _this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    return _this;
  }

  var _proto = WebGLRenderTarget.prototype;

  _proto.setTexture = function setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  };

  _proto.setSize = function setSize(width, height, depth) {
    if (depth === void 0) {
      depth = 1;
    }

    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  };

  _proto.clone = function clone() {
    return new this.constructor().copy(this);
  };

  _proto.copy = function copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = Object.assign({}, this.texture.image); // See #20328.

    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  };

  _proto.dispose = function dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  };

  return WebGLRenderTarget;
}(EventDispatcher);

WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
export { WebGLRenderTarget };