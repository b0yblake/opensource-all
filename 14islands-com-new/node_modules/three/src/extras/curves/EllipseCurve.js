import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { Curve } from '../core/Curve.js';
import { Vector2 } from '../../math/Vector2.js';

var EllipseCurve = /*#__PURE__*/function (_Curve) {
  _inheritsLoose(EllipseCurve, _Curve);

  function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var _this;

    if (aX === void 0) {
      aX = 0;
    }

    if (aY === void 0) {
      aY = 0;
    }

    if (xRadius === void 0) {
      xRadius = 1;
    }

    if (yRadius === void 0) {
      yRadius = 1;
    }

    if (aStartAngle === void 0) {
      aStartAngle = 0;
    }

    if (aEndAngle === void 0) {
      aEndAngle = Math.PI * 2;
    }

    if (aClockwise === void 0) {
      aClockwise = false;
    }

    if (aRotation === void 0) {
      aRotation = 0;
    }

    _this = _Curve.call(this) || this;
    _this.type = 'EllipseCurve';
    _this.aX = aX;
    _this.aY = aY;
    _this.xRadius = xRadius;
    _this.yRadius = yRadius;
    _this.aStartAngle = aStartAngle;
    _this.aEndAngle = aEndAngle;
    _this.aClockwise = aClockwise;
    _this.aRotation = aRotation;
    return _this;
  }

  var _proto = EllipseCurve.prototype;

  _proto.getPoint = function getPoint(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var twoPi = Math.PI * 2;
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

    while (deltaAngle < 0) {
      deltaAngle += twoPi;
    }

    while (deltaAngle > twoPi) {
      deltaAngle -= twoPi;
    }

    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }

    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }

    var angle = this.aStartAngle + t * deltaAngle;
    var x = this.aX + this.xRadius * Math.cos(angle);
    var y = this.aY + this.yRadius * Math.sin(angle);

    if (this.aRotation !== 0) {
      var cos = Math.cos(this.aRotation);
      var sin = Math.sin(this.aRotation);
      var tx = x - this.aX;
      var ty = y - this.aY; // Rotate the point about the center of the ellipse.

      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }

    return point.set(x, y);
  };

  _proto.copy = function copy(source) {
    _Curve.prototype.copy.call(this, source);

    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  };

  _proto.toJSON = function toJSON() {
    var data = _Curve.prototype.toJSON.call(this);

    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  };

  _proto.fromJSON = function fromJSON(json) {
    _Curve.prototype.fromJSON.call(this, json);

    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  };

  return EllipseCurve;
}(Curve);

EllipseCurve.prototype.isEllipseCurve = true;
export { EllipseCurve };