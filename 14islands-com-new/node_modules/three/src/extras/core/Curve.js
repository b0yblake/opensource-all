import * as MathUtils from '../../math/MathUtils.js';
import { Vector2 } from '../../math/Vector2.js';
import { Vector3 } from '../../math/Vector3.js';
import { Matrix4 } from '../../math/Matrix4.js';
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

var Curve = /*#__PURE__*/function () {
  function Curve() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  } // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]


  var _proto = Curve.prototype;

  _proto.getPoint = function
  /* t, optionalTarget */
  getPoint() {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  } // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  ;

  _proto.getPointAt = function getPointAt(u, optionalTarget) {
    var t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  } // Get sequence of points using getPoint( t )
  ;

  _proto.getPoints = function getPoints(divisions) {
    if (divisions === void 0) {
      divisions = 5;
    }

    var points = [];

    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  } // Get sequence of points using getPointAt( u )
  ;

  _proto.getSpacedPoints = function getSpacedPoints(divisions) {
    if (divisions === void 0) {
      divisions = 5;
    }

    var points = [];

    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  } // Get total curve arc length
  ;

  _proto.getLength = function getLength() {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
  } // Get list of cumulative segment lengths
  ;

  _proto.getLengths = function getLengths(divisions) {
    if (divisions === void 0) {
      divisions = this.arcLengthDivisions;
    }

    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    var cache = [];
    var current,
        last = this.getPoint(0);
    var sum = 0;
    cache.push(0);

    for (var p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  };

  _proto.updateArcLengths = function updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  ;

  _proto.getUtoTmapping = function getUtoTmapping(u, distance) {
    var arcLengths = this.getLengths();
    var i = 0;
    var il = arcLengths.length;
    var targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    var low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    var lengthBefore = arcLengths[i];
    var lengthAfter = arcLengths[i + 1];
    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    var t = (i + segmentFraction) / (il - 1);
    return t;
  } // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  ;

  _proto.getTangent = function getTangent(t, optionalTarget) {
    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t2);
    var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  };

  _proto.getTangentAt = function getTangentAt(u, optionalTarget) {
    var t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  };

  _proto.computeFrenetFrames = function computeFrenetFrames(segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    var normal = new Vector3();
    var tangents = [];
    var normals = [];
    var binormals = [];
    var vec = new Vector3();
    var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

    for (var i = 0; i <= segments; i++) {
      var u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    var min = Number.MAX_VALUE;
    var tx = Math.abs(tangents[0].x);
    var ty = Math.abs(tangents[0].y);
    var tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (var _i = 1; _i <= segments; _i++) {
      normals[_i] = normals[_i - 1].clone();
      binormals[_i] = binormals[_i - 1].clone();
      vec.crossVectors(tangents[_i - 1], tangents[_i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        var theta = Math.acos(MathUtils.clamp(tangents[_i - 1].dot(tangents[_i]), -1, 1)); // clamp for floating pt errors

        normals[_i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[_i].crossVectors(tangents[_i], normals[_i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      var _theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));

      _theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        _theta = -_theta;
      }

      for (var _i2 = 1; _i2 <= segments; _i2++) {
        // twist a little...
        normals[_i2].applyMatrix4(mat.makeRotationAxis(tangents[_i2], _theta * _i2));

        binormals[_i2].crossVectors(tangents[_i2], normals[_i2]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  };

  _proto.clone = function clone() {
    return new this.constructor().copy(this);
  };

  _proto.copy = function copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  };

  _proto.toJSON = function toJSON() {
    var data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  };

  _proto.fromJSON = function fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  };

  return Curve;
}();

export { Curve };