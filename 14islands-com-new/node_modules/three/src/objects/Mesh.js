import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { Vector3 } from '../math/Vector3.js';
import { Vector2 } from '../math/Vector2.js';
import { Sphere } from '../math/Sphere.js';
import { Ray } from '../math/Ray.js';
import { Matrix4 } from '../math/Matrix4.js';
import { Object3D } from '../core/Object3D.js';
import { Triangle } from '../math/Triangle.js';
import { DoubleSide, BackSide } from '../constants.js';
import { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';
import { BufferGeometry } from '../core/BufferGeometry.js';

var _inverseMatrix = /*@__PURE__*/new Matrix4();

var _ray = /*@__PURE__*/new Ray();

var _sphere = /*@__PURE__*/new Sphere();

var _vA = /*@__PURE__*/new Vector3();

var _vB = /*@__PURE__*/new Vector3();

var _vC = /*@__PURE__*/new Vector3();

var _tempA = /*@__PURE__*/new Vector3();

var _tempB = /*@__PURE__*/new Vector3();

var _tempC = /*@__PURE__*/new Vector3();

var _morphA = /*@__PURE__*/new Vector3();

var _morphB = /*@__PURE__*/new Vector3();

var _morphC = /*@__PURE__*/new Vector3();

var _uvA = /*@__PURE__*/new Vector2();

var _uvB = /*@__PURE__*/new Vector2();

var _uvC = /*@__PURE__*/new Vector2();

var _intersectionPoint = /*@__PURE__*/new Vector3();

var _intersectionPointWorld = /*@__PURE__*/new Vector3();

var Mesh = /*#__PURE__*/function (_Object3D) {
  _inheritsLoose(Mesh, _Object3D);

  function Mesh(geometry, material) {
    var _this;

    if (geometry === void 0) {
      geometry = new BufferGeometry();
    }

    if (material === void 0) {
      material = new MeshBasicMaterial();
    }

    _this = _Object3D.call(this) || this;
    _this.type = 'Mesh';
    _this.geometry = geometry;
    _this.material = material;

    _this.updateMorphTargets();

    return _this;
  }

  var _proto = Mesh.prototype;

  _proto.copy = function copy(source) {
    _Object3D.prototype.copy.call(this, source);

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  };

  _proto.updateMorphTargets = function updateMorphTargets() {
    var geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
            var name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      var morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  };

  _proto.raycast = function raycast(raycaster, intersects) {
    var geometry = this.geometry;
    var material = this.material;
    var matrixWorld = this.matrixWorld;
    if (material === undefined) return; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere.copy(geometry.boundingSphere);

    _sphere.applyMatrix4(matrixWorld);

    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

    _inverseMatrix.copy(matrixWorld).invert();

    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false) return;
    }

    var intersection;

    if (geometry.isBufferGeometry) {
      var index = geometry.index;
      var position = geometry.attributes.position;
      var morphPosition = geometry.morphAttributes.position;
      var morphTargetsRelative = geometry.morphTargetsRelative;
      var uv = geometry.attributes.uv;
      var uv2 = geometry.attributes.uv2;
      var groups = geometry.groups;
      var drawRange = geometry.drawRange;

      if (index !== null) {
        // indexed buffer geometry
        if (Array.isArray(material)) {
          for (var i = 0, il = groups.length; i < il; i++) {
            var group = groups[i];
            var groupMaterial = material[group.materialIndex];
            var start = Math.max(group.start, drawRange.start);
            var end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (var j = start, jl = end; j < jl; j += 3) {
              var a = index.getX(j);
              var b = index.getX(j + 1);
              var c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          var _start = Math.max(0, drawRange.start);

          var _end = Math.min(index.count, drawRange.start + drawRange.count);

          for (var _i = _start, _il = _end; _i < _il; _i += 3) {
            var _a = index.getX(_i);

            var _b = index.getX(_i + 1);

            var _c = index.getX(_i + 2);

            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);

            if (intersection) {
              intersection.faceIndex = Math.floor(_i / 3); // triangle number in indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry
        if (Array.isArray(material)) {
          for (var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++) {
            var _group = groups[_i2];
            var _groupMaterial = material[_group.materialIndex];

            var _start2 = Math.max(_group.start, drawRange.start);

            var _end2 = Math.min(_group.start + _group.count, drawRange.start + drawRange.count);

            for (var _j = _start2, _jl = _end2; _j < _jl; _j += 3) {
              var _a2 = _j;

              var _b2 = _j + 1;

              var _c2 = _j + 2;

              intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);

              if (intersection) {
                intersection.faceIndex = Math.floor(_j / 3); // triangle number in non-indexed buffer semantics

                intersection.face.materialIndex = _group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          var _start3 = Math.max(0, drawRange.start);

          var _end3 = Math.min(position.count, drawRange.start + drawRange.count);

          for (var _i3 = _start3, _il3 = _end3; _i3 < _il3; _i3 += 3) {
            var _a3 = _i3;

            var _b3 = _i3 + 1;

            var _c3 = _i3 + 2;

            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);

            if (intersection) {
              intersection.faceIndex = Math.floor(_i3 / 3); // triangle number in non-indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  };

  return Mesh;
}(Object3D);

Mesh.prototype.isMesh = true;

function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  var intersect;

  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }

  if (intersect === null) return null;

  _intersectionPointWorld.copy(point);

  _intersectionPointWorld.applyMatrix4(object.matrixWorld);

  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}

function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA.fromBufferAttribute(position, a);

  _vB.fromBufferAttribute(position, b);

  _vC.fromBufferAttribute(position, c);

  var morphInfluences = object.morphTargetInfluences;

  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);

    _morphB.set(0, 0, 0);

    _morphC.set(0, 0, 0);

    for (var i = 0, il = morphPosition.length; i < il; i++) {
      var influence = morphInfluences[i];
      var morphAttribute = morphPosition[i];
      if (influence === 0) continue;

      _tempA.fromBufferAttribute(morphAttribute, a);

      _tempB.fromBufferAttribute(morphAttribute, b);

      _tempC.fromBufferAttribute(morphAttribute, c);

      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);

        _morphB.addScaledVector(_tempB, influence);

        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);

        _morphB.addScaledVector(_tempB.sub(_vB), influence);

        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }

    _vA.add(_morphA);

    _vB.add(_morphB);

    _vC.add(_morphC);
  }

  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA);
    object.boneTransform(b, _vB);
    object.boneTransform(c, _vC);
  }

  var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);

      _uvB.fromBufferAttribute(uv, b);

      _uvC.fromBufferAttribute(uv, c);

      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a);

      _uvB.fromBufferAttribute(uv2, b);

      _uvC.fromBufferAttribute(uv2, c);

      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    var face = {
      a: a,
      b: b,
      c: c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }

  return intersection;
}

export { Mesh };