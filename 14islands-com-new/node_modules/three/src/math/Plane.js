import { Matrix3 } from './Matrix3.js';
import { Vector3 } from './Vector3.js';

var _vector1 = /*@__PURE__*/new Vector3();

var _vector2 = /*@__PURE__*/new Vector3();

var _normalMatrix = /*@__PURE__*/new Matrix3();

var Plane = /*#__PURE__*/function () {
  function Plane(normal, constant) {
    if (normal === void 0) {
      normal = new Vector3(1, 0, 0);
    }

    if (constant === void 0) {
      constant = 0;
    } // normal is assumed to be normalized


    this.normal = normal;
    this.constant = constant;
  }

  var _proto = Plane.prototype;

  _proto.set = function set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  };

  _proto.setComponents = function setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  };

  _proto.setFromNormalAndCoplanarPoint = function setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  };

  _proto.setFromCoplanarPoints = function setFromCoplanarPoints(a, b, c) {
    var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  };

  _proto.copy = function copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  };

  _proto.normalize = function normalize() {
    // Note: will lead to a divide by zero if the plane is invalid.
    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  };

  _proto.negate = function negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  };

  _proto.distanceToPoint = function distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  };

  _proto.distanceToSphere = function distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  };

  _proto.projectPoint = function projectPoint(point, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  };

  _proto.intersectLine = function intersectLine(line, target) {
    var direction = line.delta(_vector1);
    var denominator = this.normal.dot(direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      } // Unsure if this is the correct method to handle this case.


      return null;
    }

    var t = -(line.start.dot(this.normal) + this.constant) / denominator;

    if (t < 0 || t > 1) {
      return null;
    }

    return target.copy(direction).multiplyScalar(t).add(line.start);
  };

  _proto.intersectsLine = function intersectsLine(line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  };

  _proto.intersectsBox = function intersectsBox(box) {
    return box.intersectsPlane(this);
  };

  _proto.intersectsSphere = function intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  };

  _proto.coplanarPoint = function coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  };

  _proto.applyMatrix4 = function applyMatrix4(matrix, optionalNormalMatrix) {
    var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

    var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    var normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  };

  _proto.translate = function translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  };

  _proto.equals = function equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  };

  _proto.clone = function clone() {
    return new this.constructor().copy(this);
  };

  return Plane;
}();

Plane.prototype.isPlane = true;
export { Plane };