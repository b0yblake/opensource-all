import { Box3 } from './Box3.js';
import { Vector3 } from './Vector3.js';

var _box = /*@__PURE__*/new Box3();

var _v1 = /*@__PURE__*/new Vector3();

var _toFarthestPoint = /*@__PURE__*/new Vector3();

var _toPoint = /*@__PURE__*/new Vector3();

var Sphere = /*#__PURE__*/function () {
  function Sphere(center, radius) {
    if (center === void 0) {
      center = new Vector3();
    }

    if (radius === void 0) {
      radius = -1;
    }

    this.center = center;
    this.radius = radius;
  }

  var _proto = Sphere.prototype;

  _proto.set = function set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  };

  _proto.setFromPoints = function setFromPoints(points, optionalCenter) {
    var center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box.setFromPoints(points).getCenter(center);
    }

    var maxRadiusSq = 0;

    for (var i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  };

  _proto.copy = function copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  };

  _proto.isEmpty = function isEmpty() {
    return this.radius < 0;
  };

  _proto.makeEmpty = function makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  };

  _proto.containsPoint = function containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  };

  _proto.distanceToPoint = function distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  };

  _proto.intersectsSphere = function intersectsSphere(sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  };

  _proto.intersectsBox = function intersectsBox(box) {
    return box.intersectsSphere(this);
  };

  _proto.intersectsPlane = function intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  };

  _proto.clampPoint = function clampPoint(point, target) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  };

  _proto.getBoundingBox = function getBoundingBox(target) {
    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  };

  _proto.applyMatrix4 = function applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  };

  _proto.translate = function translate(offset) {
    this.center.add(offset);
    return this;
  };

  _proto.expandByPoint = function expandByPoint(point) {
    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
    _toPoint.subVectors(point, this.center);

    var lengthSq = _toPoint.lengthSq();

    if (lengthSq > this.radius * this.radius) {
      var length = Math.sqrt(lengthSq);
      var missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
      // and the other half to position. This gives a tighter enclosure, instead of if
      // the whole missing distance were just added to radius.

      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }

    return this;
  };

  _proto.union = function union(sphere) {
    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
    // To enclose another sphere into this sphere, we only need to enclose two points:
    // 1) Enclose the farthest point on the other sphere into this sphere.
    // 2) Enclose the opposite point of the farthest point into this sphere.
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

    this.expandByPoint(_v1.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  };

  _proto.equals = function equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  };

  _proto.clone = function clone() {
    return new this.constructor().copy(this);
  };

  return Sphere;
}();

export { Sphere };