import _defineProperty from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/defineProperty.js";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import { RichTextNodeType } from '@prismicio/types';
export { RichTextNodeType as Element } from '@prismicio/types';

var uuid = function uuid() {
  return (++uuid.i).toString();
};

uuid.i = 0;

var asTree = function asTree(nodes) {
  var preparedNodes = prepareNodes(nodes);
  var children = [];

  for (var i = 0; i < preparedNodes.length; i++) {
    children.push(nodeToTreeNode(preparedNodes[i]));
  }

  return {
    key: uuid(),
    children
  };
};

var createTreeNode = function createTreeNode(node) {
  var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    key: uuid(),
    type: node.type,
    text: "text" in node ? node.text : void 0,
    node,
    children
  };
};

var createTextTreeNode = function createTextTreeNode(text) {
  return createTreeNode({
    type: RichTextNodeType.span,
    text,
    spans: []
  });
};

var prepareNodes = function prepareNodes(nodes) {
  var mutNodes = nodes.slice(0);

  for (var i = 0; i < mutNodes.length; i++) {
    var node = mutNodes[i];

    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {
      var items = [node];

      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {
        items.push(mutNodes[i + 1]);
        mutNodes.splice(i, 1);
      }

      if (node.type === RichTextNodeType.listItem) {
        mutNodes[i] = {
          type: RichTextNodeType.list,
          items
        };
      } else {
        mutNodes[i] = {
          type: RichTextNodeType.oList,
          items
        };
      }
    }
  }

  return mutNodes;
};

var nodeToTreeNode = function nodeToTreeNode(node) {
  if ("text" in node) {
    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));
  }

  if ("items" in node) {
    var children = [];

    for (var i = 0; i < node.items.length; i++) {
      children.push(nodeToTreeNode(node.items[i]));
    }

    return createTreeNode(node, children);
  }

  return createTreeNode(node);
};

var textNodeSpansToTreeNodeChildren = function textNodeSpansToTreeNodeChildren(spans, node, parentSpan) {
  if (!spans.length) {
    return [createTextTreeNode(node.text)];
  }

  var mutSpans = spans.slice(0);
  mutSpans.sort(function (a, b) {
    return a.start - b.start || b.end - a.end;
  });
  var children = [];

  for (var i = 0; i < mutSpans.length; i++) {
    var span = mutSpans[i];
    var parentSpanStart = parentSpan && parentSpan.start || 0;
    var spanStart = span.start - parentSpanStart;
    var spanEnd = span.end - parentSpanStart;
    var childSpans = [];

    for (var j = i; j < mutSpans.length; j++) {
      var siblingSpan = mutSpans[j];

      if (siblingSpan !== span && siblingSpan.start >= span.start && siblingSpan.end <= span.end) {
        childSpans.push(siblingSpan);
        mutSpans.splice(j, 1);
        j--;
      }
    }

    if (i === 0 && spanStart > 0) {
      children.push(createTextTreeNode(node.text.slice(0, spanStart)));
    }

    children.push(createTreeNode(span, textNodeSpansToTreeNodeChildren(childSpans, _objectSpread(_objectSpread({}, node), {}, {
      text: node.text.slice(spanStart, spanEnd)
    }), span)));

    if (spanEnd < node.text.length) {
      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));
    }
  }

  return children;
};

var asText = function asText(richTextField) {
  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : " ";
  var result = "";

  for (var i = 0; i < richTextField.length; i++) {
    if ("text" in richTextField[i]) {
      result += (result ? separator : "") + richTextField[i].text;
    }
  }

  return result;
};

var serialize = function serialize(richTextField, serializer) {
  return serializeTreeNodes(asTree(richTextField).children, serializer);
};

var serializeTreeNodes = function serializeTreeNodes(nodes, serializer) {
  var serializedTreeNodes = [];

  for (var i = 0; i < nodes.length; i++) {
    var treeNode = nodes[i];
    var serializedTreeNode = serializer(treeNode.type, treeNode.node, treeNode.text, serializeTreeNodes(treeNode.children, serializer), treeNode.key);

    if (serializedTreeNode != null) {
      serializedTreeNodes.push(serializedTreeNode);
    }
  }

  return serializedTreeNodes;
};

var RichTextReversedNodeType = {
  [RichTextNodeType.listItem]: "listItem",
  [RichTextNodeType.oListItem]: "oListItem",
  [RichTextNodeType.list]: "list",
  [RichTextNodeType.oList]: "oList"
};

var wrapMapSerializer = function wrapMapSerializer(mapSerializer) {
  return function (type, node, text, children, key) {
    var tagSerializer = mapSerializer[RichTextReversedNodeType[type] || type];

    if (tagSerializer) {
      return tagSerializer({
        type,
        node,
        text,
        children,
        key
      });
    }
  };
};

var composeSerializers = function composeSerializers() {
  for (var _len = arguments.length, serializers = new Array(_len), _key = 0; _key < _len; _key++) {
    serializers[_key] = arguments[_key];
  }

  return function () {
    for (var i = 0; i < serializers.length; i++) {
      var serializer = serializers[i];

      if (serializer) {
        var res = serializer.apply(void 0, arguments);

        if (res != null) {
          return res;
        }
      }
    }
  };
};

export { asText, asTree, composeSerializers, serialize, wrapMapSerializer };