import { onNextFrame, defaultTimestep } from './on-next-frame.mjs';
import { createRenderStep } from './create-render-step.mjs';
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];
var steps = stepsOrder.reduce(function (acc, key) {
  acc[key] = createRenderStep(function () {
    return runNextFrame = true;
  });
  return acc;
}, {});
var sync = stepsOrder.reduce(function (acc, key) {
  var step = steps[key];

  acc[key] = function (process) {
    var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (!runNextFrame) startLoop();
    return step.schedule(process, keepAlive, immediate);
  };

  return acc;
}, {});
var cancelSync = stepsOrder.reduce(function (acc, key) {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder.reduce(function (acc, key) {
  acc[key] = function () {
    return steps[key].process(frame);
  };

  return acc;
}, {});

var processStep = function processStep(stepId) {
  return steps[stepId].process(frame);
};

var processFrame = function processFrame(timestamp) {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;

  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};

var startLoop = function startLoop() {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing) onNextFrame(processFrame);
};

var getFrameData = function getFrameData() {
  return frame;
};

export default sync;
export { cancelSync, flushSync, getFrameData };