import { identity, pipe as pipeFromFunctionModule } from './function';

var isFunctor = function isFunctor(I) {
  return typeof I.map === 'function';
};

var isContravariant = function isContravariant(I) {
  return typeof I.contramap === 'function';
};

var isFunctorWithIndex = function isFunctorWithIndex(I) {
  return typeof I.mapWithIndex === 'function';
};

var isApply = function isApply(I) {
  return typeof I.ap === 'function';
};

var isChain = function isChain(I) {
  return typeof I.chain === 'function';
};

var isBifunctor = function isBifunctor(I) {
  return typeof I.bimap === 'function';
};

var isExtend = function isExtend(I) {
  return typeof I.extend === 'function';
};

var isFoldable = function isFoldable(I) {
  return typeof I.reduce === 'function';
};

var isFoldableWithIndex = function isFoldableWithIndex(I) {
  return typeof I.reduceWithIndex === 'function';
};

var isAlt = function isAlt(I) {
  return typeof I.alt === 'function';
};

var isCompactable = function isCompactable(I) {
  return typeof I.compact === 'function';
};

var isFilterable = function isFilterable(I) {
  return typeof I.filter === 'function';
};

var isFilterableWithIndex = function isFilterableWithIndex(I) {
  return typeof I.filterWithIndex === 'function';
};

var isProfunctor = function isProfunctor(I) {
  return typeof I.promap === 'function';
};

var isSemigroupoid = function isSemigroupoid(I) {
  return typeof I.compose === 'function';
};

var isMonadThrow = function isMonadThrow(I) {
  return typeof I.throwError === 'function';
};
/** @deprecated */


export function pipeable(I) {
  var r = {};

  if (isFunctor(I)) {
    var map = function map(f) {
      return function (fa) {
        return I.map(fa, f);
      };
    };

    r.map = map;
  }

  if (isContravariant(I)) {
    var contramap = function contramap(f) {
      return function (fa) {
        return I.contramap(fa, f);
      };
    };

    r.contramap = contramap;
  }

  if (isFunctorWithIndex(I)) {
    var mapWithIndex = function mapWithIndex(f) {
      return function (fa) {
        return I.mapWithIndex(fa, f);
      };
    };

    r.mapWithIndex = mapWithIndex;
  }

  if (isApply(I)) {
    var ap = function ap(fa) {
      return function (fab) {
        return I.ap(fab, fa);
      };
    };

    var apFirst = function apFirst(fb) {
      return function (fa) {
        return I.ap(I.map(fa, function (a) {
          return function () {
            return a;
          };
        }), fb);
      };
    };

    r.ap = ap;
    r.apFirst = apFirst;

    r.apSecond = function (fb) {
      return function (fa) {
        return I.ap(I.map(fa, function () {
          return function (b) {
            return b;
          };
        }), fb);
      };
    };
  }

  if (isChain(I)) {
    var chain = function chain(f) {
      return function (ma) {
        return I.chain(ma, f);
      };
    };

    var chainFirst = function chainFirst(f) {
      return function (ma) {
        return I.chain(ma, function (a) {
          return I.map(f(a), function () {
            return a;
          });
        });
      };
    };

    var flatten = function flatten(mma) {
      return I.chain(mma, identity);
    };

    r.chain = chain;
    r.chainFirst = chainFirst;
    r.flatten = flatten;
  }

  if (isBifunctor(I)) {
    var bimap = function bimap(f, g) {
      return function (fa) {
        return I.bimap(fa, f, g);
      };
    };

    var mapLeft = function mapLeft(f) {
      return function (fa) {
        return I.mapLeft(fa, f);
      };
    };

    r.bimap = bimap;
    r.mapLeft = mapLeft;
  }

  if (isExtend(I)) {
    var extend = function extend(f) {
      return function (wa) {
        return I.extend(wa, f);
      };
    };

    var duplicate = function duplicate(wa) {
      return I.extend(wa, identity);
    };

    r.extend = extend;
    r.duplicate = duplicate;
  }

  if (isFoldable(I)) {
    var reduce = function reduce(b, f) {
      return function (fa) {
        return I.reduce(fa, b, f);
      };
    };

    var foldMap = function foldMap(M) {
      var foldMapM = I.foldMap(M);
      return function (f) {
        return function (fa) {
          return foldMapM(fa, f);
        };
      };
    };

    var reduceRight = function reduceRight(b, f) {
      return function (fa) {
        return I.reduceRight(fa, b, f);
      };
    };

    r.reduce = reduce;
    r.foldMap = foldMap;
    r.reduceRight = reduceRight;
  }

  if (isFoldableWithIndex(I)) {
    var reduceWithIndex = function reduceWithIndex(b, f) {
      return function (fa) {
        return I.reduceWithIndex(fa, b, f);
      };
    };

    var foldMapWithIndex = function foldMapWithIndex(M) {
      var foldMapM = I.foldMapWithIndex(M);
      return function (f) {
        return function (fa) {
          return foldMapM(fa, f);
        };
      };
    };

    var reduceRightWithIndex = function reduceRightWithIndex(b, f) {
      return function (fa) {
        return I.reduceRightWithIndex(fa, b, f);
      };
    };

    r.reduceWithIndex = reduceWithIndex;
    r.foldMapWithIndex = foldMapWithIndex;
    r.reduceRightWithIndex = reduceRightWithIndex;
  }

  if (isAlt(I)) {
    var alt = function alt(that) {
      return function (fa) {
        return I.alt(fa, that);
      };
    };

    r.alt = alt;
  }

  if (isCompactable(I)) {
    r.compact = I.compact;
    r.separate = I.separate;
  }

  if (isFilterable(I)) {
    var filter = function filter(predicate) {
      return function (fa) {
        return I.filter(fa, predicate);
      };
    };

    var filterMap = function filterMap(f) {
      return function (fa) {
        return I.filterMap(fa, f);
      };
    };

    var partition = function partition(predicate) {
      return function (fa) {
        return I.partition(fa, predicate);
      };
    };

    var partitionMap = function partitionMap(f) {
      return function (fa) {
        return I.partitionMap(fa, f);
      };
    };

    r.filter = filter;
    r.filterMap = filterMap;
    r.partition = partition;
    r.partitionMap = partitionMap;
  }

  if (isFilterableWithIndex(I)) {
    var filterWithIndex = function filterWithIndex(predicateWithIndex) {
      return function (fa) {
        return I.filterWithIndex(fa, predicateWithIndex);
      };
    };

    var filterMapWithIndex = function filterMapWithIndex(f) {
      return function (fa) {
        return I.filterMapWithIndex(fa, f);
      };
    };

    var partitionWithIndex = function partitionWithIndex(predicateWithIndex) {
      return function (fa) {
        return I.partitionWithIndex(fa, predicateWithIndex);
      };
    };

    var partitionMapWithIndex = function partitionMapWithIndex(f) {
      return function (fa) {
        return I.partitionMapWithIndex(fa, f);
      };
    };

    r.filterWithIndex = filterWithIndex;
    r.filterMapWithIndex = filterMapWithIndex;
    r.partitionWithIndex = partitionWithIndex;
    r.partitionMapWithIndex = partitionMapWithIndex;
  }

  if (isProfunctor(I)) {
    var promap = function promap(f, g) {
      return function (fa) {
        return I.promap(fa, f, g);
      };
    };

    r.promap = promap;
  }

  if (isSemigroupoid(I)) {
    var compose = function compose(that) {
      return function (fa) {
        return I.compose(fa, that);
      };
    };

    r.compose = compose;
  }

  if (isMonadThrow(I)) {
    var fromOption = function fromOption(onNone) {
      return function (ma) {
        return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);
      };
    };

    var fromEither = function fromEither(ma) {
      return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);
    };

    var fromPredicate = function fromPredicate(predicate, onFalse) {
      return function (a) {
        return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
      };
    };

    var filterOrElse = function filterOrElse(predicate, onFalse) {
      return function (ma) {
        return I.chain(ma, function (a) {
          return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
        });
      };
    };

    r.fromOption = fromOption;
    r.fromEither = fromEither;
    r.fromPredicate = fromPredicate;
    r.filterOrElse = filterOrElse;
  }

  return r;
}
/**
 * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
 *
 * @since 2.0.0
 * @deprecated
 */

export var pipe = pipeFromFunctionModule;