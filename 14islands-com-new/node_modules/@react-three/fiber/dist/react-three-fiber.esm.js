import _classCallCheck from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/classCallCheck.js";
import _createClass from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/createClass.js";
import _inherits from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/inherits.js";
import _possibleConstructorReturn from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js";
import _getPrototypeOf from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js";
import _construct from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/construct.js";
import _toArray from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/toArray.js";
import _slicedToArray from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/slicedToArray.js";
import _objectWithoutProperties from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js";
import _toConsumableArray from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js";
import _defineProperty from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/defineProperty.js";
var _excluded = ["children", "key", "ref"],
    _excluded2 = ["children", "key", "ref"],
    _excluded3 = ["args"],
    _excluded4 = ["args", "children"],
    _excluded5 = ["args", "children"],
    _excluded6 = ["params"],
    _excluded7 = ["children", "fallback", "tabIndex", "resize", "id", "style", "className", "events"],
    _excluded8 = ["gl", "size", "mode", "events", "onCreated"];

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import "core-js/modules/es.array.flat.js";
import "core-js/modules/es.array.unscopables.flat.js";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import * as THREE from 'three';
import * as React from 'react';
import create from 'zustand';
import Reconciler from 'react-reconciler';
import { unstable_now, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';
import { useAsset } from 'use-asset';
import mergeRefs from 'react-merge-refs';
import useMeasure from 'react-use-measure';
var threeTypes = /*#__PURE__*/Object.freeze({
  __proto__: null
});
var is = {
  obj: function obj(a) {
    return a === Object(a) && !is.arr(a) && typeof a !== 'function';
  },
  fun: function fun(a) {
    return typeof a === 'function';
  },
  str: function str(a) {
    return typeof a === 'string';
  },
  num: function num(a) {
    return typeof a === 'number';
  },
  und: function und(a) {
    return a === void 0;
  },
  arr: function arr(a) {
    return Array.isArray(a);
  },

  equ(a, b) {
    // Wrong type or one of the two undefined, doesn't match
    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b

    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match

    if (is.arr(a) && a == b) return true; // Last resort, go through keys

    var i;

    for (i in a) {
      if (!(i in b)) return false;
    }

    for (i in b) {
      if (a[i] !== b[i]) return false;
    }

    return is.und(i) ? a === b : true;
  }

};

function makeId(event) {
  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;
}
/**
 * Release pointer captures.
 * This is called by releasePointerCapture in the API, and when an object is removed.
 */


function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {
  var captureData = captures.get(obj);

  if (captureData) {
    captures.delete(obj); // If this was the last capturing object for this pointer

    if (captures.size === 0) {
      capturedMap.delete(pointerId);
      captureData.target.releasePointerCapture(pointerId);
    }
  }
}

function removeInteractivity(store, object) {
  var _store$getState = store.getState(),
      internal = _store$getState.internal; // Removes every trace of an object from the data store


  internal.interaction = internal.interaction.filter(function (o) {
    return o !== object;
  });
  internal.initialHits = internal.initialHits.filter(function (o) {
    return o !== object;
  });
  internal.hovered.forEach(function (value, key) {
    if (value.eventObject === object || value.object === object) {
      internal.hovered.delete(key);
    }
  });
  internal.capturedMap.forEach(function (captures, pointerId) {
    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);
  });
}

function createEvents(store) {
  var temp = new THREE.Vector3();
  /** Sets up defaultRaycaster */

  function prepareRay(event) {
    var _raycaster$computeOff;

    var state = store.getState();
    var raycaster = state.raycaster,
        mouse = state.mouse,
        camera = state.camera,
        size = state.size; // https://github.com/pmndrs/react-three-fiber/pull/782
    // Events trigger outside of canvas when moved

    var _ref2 = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event,
        offsetX = _ref2.offsetX,
        offsetY = _ref2.offsetY;

    var width = size.width,
        height = size.height;
    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);
    raycaster.setFromCamera(mouse, camera);
  }
  /** Calculates delta */


  function calculateDistance(event) {
    var _store$getState2 = store.getState(),
        internal = _store$getState2.internal;

    var dx = event.offsetX - internal.initialClick[0];
    var dy = event.offsetY - internal.initialClick[1];
    return Math.round(Math.sqrt(dx * dx + dy * dy));
  }
  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */


  function filterPointerEvents(objects) {
    return objects.filter(function (obj) {
      return ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(function (name) {
        var _r3f;

        return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];
      });
    });
  }

  function intersect(filter) {
    var state = store.getState();
    var raycaster = state.raycaster,
        internal = state.internal; // Skip event handling when noEvents is set

    if (!raycaster.enabled) return [];
    var seen = new Set();
    var intersections = []; // Allow callers to eliminate event objects

    var eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates

    var intersects = raycaster.intersectObjects(eventsObjects, true).filter(function (item) {
      var id = makeId(item);
      if (seen.has(id)) return false;
      seen.add(id);
      return true;
    }); // https://github.com/mrdoob/three.js/issues/16031
    // Allow custom userland intersect sort order

    if (raycaster.filter) intersects = raycaster.filter(intersects, state);

    var _iterator = _createForOfIteratorHelper(intersects),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _intersect = _step.value;
        var eventObject = _intersect.object; // Bubble event up

        while (eventObject) {
          var _r3f2;

          if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push(_objectSpread(_objectSpread({}, _intersect), {}, {
            eventObject
          }));
          eventObject = eventObject.parent;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return intersections;
  }
  /**  Creates filtered intersects and returns an array of positive hits */


  function patchIntersects(intersections, event) {
    var _store$getState3 = store.getState(),
        internal = _store$getState3.internal; // If the interaction is captured, make all capturing targets  part of the
    // intersect.


    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {
      var _iterator2 = _createForOfIteratorHelper(internal.capturedMap.get(event.pointerId).values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var captureData = _step2.value;
          intersections.push(captureData.intersection);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    return intersections;
  }
  /**  Handles intersections by forwarding them to handlers */


  function handleIntersects(intersections, event, delta, callback) {
    var _store$getState4 = store.getState(),
        raycaster = _store$getState4.raycaster,
        mouse = _store$getState4.mouse,
        camera = _store$getState4.camera,
        internal = _store$getState4.internal; // If anything has been found, forward it to the event listeners


    if (intersections.length) {
      (function () {
        var unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
        var localState = {
          stopped: false
        };

        var _iterator3 = _createForOfIteratorHelper(intersections),
            _step3;

        try {
          var _loop = function _loop() {
            var hit = _step3.value;

            var hasPointerCapture = function hasPointerCapture(id) {
              var _internal$capturedMap, _internal$capturedMap2;

              return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;
            };

            var setPointerCapture = function setPointerCapture(id) {
              var captureData = {
                intersection: hit,
                target: event.target
              };

              if (internal.capturedMap.has(id)) {
                // if the pointerId was previously captured, we add the hit to the
                // event capturedMap.
                internal.capturedMap.get(id).set(hit.eventObject, captureData);
              } else {
                // if the pointerId was not previously captured, we create a map
                // containing the hitObject, and the hit. hitObject is used for
                // faster access.
                internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));
              } // Call the original event now


              event.target.setPointerCapture(id);
            };

            var releasePointerCapture = function releasePointerCapture(id) {
              var captures = internal.capturedMap.get(id);

              if (captures) {
                releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);
              }
            }; // Add native event props


            var extractEventProps = {}; // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return "own" properties; nor Object.getPrototypeOf(event) as that *doesn't* return "own" properties, only inherited ones.

            for (var prop in event) {
              var property = event[prop]; // Only copy over atomics, leave functions alone as these should be
              // called as event.nativeEvent.fn()

              if (typeof property !== 'function') extractEventProps[prop] = property;
            }

            var raycastEvent = _objectSpread(_objectSpread(_objectSpread({}, hit), extractEventProps), {}, {
              spaceX: mouse.x,
              spaceY: mouse.y,
              intersections,
              stopped: localState.stopped,
              delta,
              unprojectedPoint,
              ray: raycaster.ray,
              camera: camera,
              // Hijack stopPropagation, which just sets a flag
              stopPropagation: function stopPropagation() {
                // https://github.com/pmndrs/react-three-fiber/issues/596
                // Events are not allowed to stop propagation if the pointer has been captured
                var capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...

                if ( // ...if this pointer hasn't been captured
                !capturesForPointer || // ... or if the hit object is capturing the pointer
                capturesForPointer.has(hit.eventObject)) {
                  raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records
                  // An event handler is only allowed to flush other handlers if it is hovered itself

                  if (internal.hovered.size && Array.from(internal.hovered.values()).find(function (i) {
                    return i.eventObject === hit.eventObject;
                  })) {
                    // Objects cannot flush out higher up objects that have already caught the event
                    var higher = intersections.slice(0, intersections.indexOf(hit));
                    cancelPointer([].concat(_toConsumableArray(higher), [hit]));
                  }
                }
              },
              // there should be a distinction between target and currentTarget
              target: {
                hasPointerCapture,
                setPointerCapture,
                releasePointerCapture
              },
              currentTarget: {
                hasPointerCapture,
                setPointerCapture,
                releasePointerCapture
              },
              sourceEvent: event,
              // deprecated
              nativeEvent: event
            }); // Call subscribers


            callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation

            if (localState.stopped === true) return "break";
          };

          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _ret = _loop();

            if (_ret === "break") break;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      })();
    }

    return intersections;
  }

  function cancelPointer(hits) {
    var _store$getState5 = store.getState(),
        internal = _store$getState5.internal;

    Array.from(internal.hovered.values()).forEach(function (hoveredObj) {
      // When no objects were hit or the the hovered object wasn't found underneath the cursor
      // we call onPointerOut and delete the object from the hovered-elements map
      if (!hits.length || !hits.find(function (hit) {
        return hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId;
      })) {
        var eventObject = hoveredObj.eventObject;
        var instance = eventObject.__r3f;
        var handlers = instance == null ? void 0 : instance.handlers;
        internal.hovered.delete(makeId(hoveredObj));

        if (instance != null && instance.eventCount) {
          // Clear out intersects, they are outdated by now
          var data = _objectSpread(_objectSpread({}, hoveredObj), {}, {
            intersections: hits || []
          });

          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);
          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);
        }
      }
    });
  }

  var handlePointer = function handlePointer(name) {
    // Deal with cancelation
    switch (name) {
      case 'onPointerLeave':
      case 'onPointerCancel':
        return function () {
          return cancelPointer([]);
        };

      case 'onLostPointerCapture':
        return function (event) {
          var _store$getState6 = store.getState(),
              internal = _store$getState6.internal;

          if ('pointerId' in event && !internal.capturedMap.has(event.pointerId)) {
            // If the object event interface had onLostPointerCapture, we'd call it here on every
            // object that's getting removed.
            internal.capturedMap.delete(event.pointerId);
            cancelPointer([]);
          }
        };
    } // Any other pointer goes here ...


    return function (event) {
      var _store$getState7 = store.getState(),
          onPointerMissed = _store$getState7.onPointerMissed,
          internal = _store$getState7.internal;

      prepareRay(event);
      internal.lastEvent.current = event; // Get fresh intersects

      var isPointerMove = name === 'onPointerMove';
      var isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';
      var filter = isPointerMove ? filterPointerEvents : undefined;
      var hits = patchIntersects(intersect(filter), event);
      var delta = isClickEvent ? calculateDistance(event) : 0; // Save initial coordinates on pointer-down

      if (name === 'onPointerDown') {
        internal.initialClick = [event.offsetX, event.offsetY];
        internal.initialHits = hits.map(function (hit) {
          return hit.eventObject;
        });
      } // If a click yields no results, pass it back to the user as a miss
      // Missed events have to come first in order to establish user-land side-effect clean up


      if (isClickEvent && !hits.length) {
        if (delta <= 2) {
          pointerMissed(event, internal.interaction);
          if (onPointerMissed) onPointerMissed(event);
        }
      } // Take care of unhover


      if (isPointerMove) cancelPointer(hits);
      handleIntersects(hits, event, delta, function (data) {
        var eventObject = data.eventObject;
        var instance = eventObject.__r3f;
        var handlers = instance == null ? void 0 : instance.handlers; // Check presence of handlers

        if (!(instance != null && instance.eventCount)) return;

        if (isPointerMove) {
          // Move event ...
          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {
            // When enter or out is present take care of hover-state
            var id = makeId(data);
            var hoveredItem = internal.hovered.get(id);

            if (!hoveredItem) {
              // If the object wasn't previously hovered, book it and call its handler
              internal.hovered.set(id, data);
              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);
              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);
            } else if (hoveredItem.stopped) {
              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
              data.stopPropagation();
            }
          } // Call mouse move


          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);
        } else {
          // All other events ...
          var handler = handlers[name];

          if (handler) {
            // Forward all events back to their respective handlers with the exception of click events,
            // which must use the initial target
            if (!isClickEvent || internal.initialHits.includes(eventObject)) {
              // Missed events have to come first
              pointerMissed(event, internal.interaction.filter(function (object) {
                return !internal.initialHits.includes(object);
              })); // Now call the handler

              handler(data);
            }
          } else {
            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit
            if (isClickEvent && internal.initialHits.includes(eventObject)) {
              pointerMissed(event, internal.interaction.filter(function (object) {
                return !internal.initialHits.includes(object);
              }));
            }
          }
        }
      });
    };
  };

  function pointerMissed(event, objects) {
    objects.forEach(function (object) {
      var _r3f3;

      return (_r3f3 = object.__r3f) == null ? void 0 : _r3f3.handlers.onPointerMissed == null ? void 0 : _r3f3.handlers.onPointerMissed(event);
    });
  }

  return {
    handlePointer
  };
}

var isDiffSet = function isDiffSet(def) {
  return def && !!def.memoized && !!def.changes;
}; // Type guard to tell a store from a portal


var isStore = function isStore(def) {
  return def && !!def.getState;
};

var getContainer = function getContainer(container, child) {
  var _container$__r3f$root, _container$__r3f;

  return {
    // If the container is not a root-store then it must be a THREE.Object3D into which part of the
    // scene is portalled into. Now there can be two variants of this, either that object is part of
    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies
    // outside react, in which case we must take the root of the child that is about to be attached to it.
    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,
    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D
    container: isStore(container) ? container.getState().scene : container
  };
};

var DEFAULT = '__default';
var EMPTY = {};
var catalogue = {};

var extend = function extend(objects) {
  return void (catalogue = _objectSpread(_objectSpread({}, catalogue), objects));
}; // Shallow check arrays, but check objects atomically


function checkShallow(a, b) {
  if (is.arr(a) && is.equ(a, b)) return true;
  if (a === b) return true;
  return false;
} // Each object in the scene carries a small LocalState descriptor


function prepare(object, state) {
  var instance = object;

  if (state != null && state.primitive || !instance.__r3f) {
    instance.__r3f = _objectSpread({
      root: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null
    }, state);
  }

  return object;
}

function createRenderer(roots) {
  // This function prepares a set of changes to be applied to the instance
  function diffProps(instance, _ref3) {
    var cN = _ref3.children,
        kN = _ref3.key,
        rN = _ref3.ref,
        props = _objectWithoutProperties(_ref3, _excluded);

    var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        cP = _ref4.children,
        kP = _ref4.key,
        rP = _ref4.ref,
        previous = _objectWithoutProperties(_ref4, _excluded2);

    var accumulative = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var _instance$__r3f;

    var localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};
    var entries = Object.entries(props);
    var changes = []; // Catch removed props, prepend them so they can be reset or removed

    if (accumulative) {
      var previousKeys = Object.keys(previous);

      for (var _i = 0; _i < previousKeys.length; _i++) {
        if (!props.hasOwnProperty(previousKeys[_i])) entries.unshift([previousKeys[_i], DEFAULT + 'remove']);
      }
    }

    entries.forEach(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          key = _ref6[0],
          value = _ref6[1];

      var _instance$__r3f2; // Bail out on primitive object


      if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === 'object') return; // When props match bail out

      if (checkShallow(value, previous[key])) return; // Collect handlers and bail out

      if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]); // Split dashed props

      var entries = [];
      if (key.includes('-')) entries = key.split('-');
      changes.push([key, value, false, entries]);
    });

    var memoized = _objectSpread({}, props);

    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;
    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;
    return {
      accumulative,
      memoized,
      changes
    };
  }

  function applyProps(instance, data) {
    var _instance$__r3f3, _root$getState, _instance$__r3f4; // Filter equals, events and reserved props


    var localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};
    var root = localState.root;
    var rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};

    var _ref7 = isDiffSet(data) ? data : diffProps(instance, data),
        memoized = _ref7.memoized,
        changes = _ref7.changes;

    var prevHandlers = localState.eventCount; // Prepare memoized props

    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;
    changes.forEach(function (_ref8) {
      var _ref9 = _slicedToArray(_ref8, 4),
          key = _ref9[0],
          value = _ref9[1],
          isEvent = _ref9[2],
          keys = _ref9[3];

      var currentInstance = instance;
      var targetProp = currentInstance[key]; // Revolve dashed props

      if (keys.length) {
        targetProp = keys.reduce(function (acc, key) {
          return acc[key];
        }, instance); // If the target is atomic, it forces us to switch the root

        if (!(targetProp && targetProp.set)) {
          var _keys$reverse = keys.reverse(),
              _keys$reverse2 = _toArray(_keys$reverse),
              name = _keys$reverse2[0],
              reverseEntries = _keys$reverse2.slice(1);

          currentInstance = reverseEntries.reverse().reduce(function (acc, key) {
            return acc[key];
          }, instance);
          key = name;
        }
      } // https://github.com/mrdoob/three.js/issues/21209
      // HMR/fast-refresh relies on the ability to cancel out props, but threejs
      // has no means to do this. Hence we curate a small collection of value-classes
      // with their respective constructor/set arguments
      // For removed props, try to set default values, if possible


      if (value === DEFAULT + 'remove') {
        if (targetProp && targetProp.constructor) {
          // use the prop constructor to find the default it should be
          value = new targetProp.constructor(memoized.args);
        } else if (currentInstance.constructor) {
          // create a blank slate of the instance and copy the particular parameter.
          // @ts-ignore
          var defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);
          value = defaultClassCall[targetProp]; // destory the instance

          if (defaultClassCall.dispose) defaultClassCall.dispose(); // instance does not have constructor, just set it to 0
        } else value = 0;
      } // Deal with pointer events ...


      if (isEvent) {
        if (value) localState.handlers[key] = value;else delete localState.handlers[key];
        localState.eventCount = Object.keys(localState.handlers).length;
      } // Special treatment for objects with support for set/copy, and layers
      else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE.Layers)) {
        // If value is an array
        if (Array.isArray(value)) {
          var _targetProp;

          if (targetProp.fromArray) targetProp.fromArray(value);else (_targetProp = targetProp).set.apply(_targetProp, _toConsumableArray(value));
        } // Test again target.copy(class) next ...
        else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) targetProp.copy(value); // If nothing else fits, just set the single value, ignore undefined
        // https://github.com/pmndrs/react-three-fiber/issues/274
        else if (value !== undefined) {
          var isColor = targetProp instanceof THREE.Color; // Allow setting array scalars

          if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property
          else if (targetProp instanceof THREE.Layers && value instanceof THREE.Layers) targetProp.mask = value.mask; // Otherwise just set ...
          else targetProp.set(value); // Auto-convert sRGB colors, for now ...
          // https://github.com/pmndrs/react-three-fiber/issues/344

          if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();
        } // Else, just overwrite the value

      } else {
        currentInstance[key] = value; // Auto-convert sRGB textures, for now ...
        // https://github.com/pmndrs/react-three-fiber/issues/344

        if (!rootState.linear && currentInstance[key] instanceof THREE.Texture) currentInstance[key].encoding = THREE.sRGBEncoding;
      }

      invalidateInstance(instance);
    });

    if (localState.parent && rootState.internal && instance.raycast && prevHandlers !== localState.eventCount) {
      // Pre-emptively remove the instance from the interaction manager
      var index = rootState.internal.interaction.indexOf(instance);
      if (index > -1) rootState.internal.interaction.splice(index, 1); // Add the instance to the interaction manager only when it has handlers

      if (localState.eventCount) rootState.internal.interaction.push(instance);
    } // Call the update lifecycle when it is being updated


    if (changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);
    return instance;
  }

  function invalidateInstance(instance) {
    var _instance$__r3f5, _instance$__r3f5$root;

    var state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();
    if (state && state.internal.frames === 0) state.invalidate();
  }

  function updateInstance(instance) {
    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);
  }

  function createInstance(type, _ref10, root, hostContext, internalInstanceHandle) {
    var _ref10$args = _ref10.args,
        args = _ref10$args === void 0 ? [] : _ref10$args,
        props = _objectWithoutProperties(_ref10, _excluded3);

    var name = "".concat(type[0].toUpperCase()).concat(type.slice(1));
    var instance; // https://github.com/facebook/react/issues/17147
    // Portals do not give us a root, they are themselves treated as a root by the reconciler
    // In order to figure out the actual root we have to climb through fiber internals :(

    if (!isStore(root) && internalInstanceHandle) {
      var fn = function fn(node) {
        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);
      };

      root = fn(internalInstanceHandle);
    } // Assert that by now we have a valid root


    if (!root || !isStore(root)) throw "No valid root for ".concat(name, "!");

    if (type === 'primitive') {
      if (props.object === undefined) throw "Primitives without 'object' are invalid!";
      var object = props.object;
      instance = prepare(object, {
        root,
        primitive: true
      });
    } else {
      var target = catalogue[name] || THREE[name];
      if (!target) throw "".concat(name, " is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively"); // Throw if an object or literal was passed for args

      if (!Array.isArray(args)) throw 'The args prop must be an array!'; // Instanciate new object, link it to the root
      // Append memoized props with args so it's not forgotten

      instance = prepare(_construct(target, _toConsumableArray(args)), {
        root,
        memoizedProps: {
          args: args.length === 0 ? null : args
        }
      });
    } // Auto-attach geometries and materials


    if (!('attachFns' in props)) {
      if (name.endsWith('Geometry')) {
        props = _objectSpread({
          attach: 'geometry'
        }, props);
      } else if (name.endsWith('Material')) {
        props = _objectSpread({
          attach: 'material'
        }, props);
      }
    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the
    // view yet. If the callback relies on references for instance, they won't be ready yet, this is
    // why it passes "true" here


    applyProps(instance, props);
    return instance;
  }

  function appendChild(parentInstance, child) {
    var addedAsChild = false;

    if (child) {
      // The attach attribute implies that the object attaches itself on the parent
      if (child.attachArray) {
        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];
        parentInstance[child.attachArray].push(child);
      } else if (child.attachObject) {
        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};
        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;
      } else if (child.attach && !is.fun(child.attach)) {
        parentInstance[child.attach] = child;
      } else if (is.arr(child.attachFns)) {
        var _child$attachFns = _slicedToArray(child.attachFns, 1),
            attachFn = _child$attachFns[0];

        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {
          parentInstance[attachFn](child);
        } else if (is.fun(attachFn)) {
          attachFn(child, parentInstance);
        }
      } else if (child.isObject3D && parentInstance.isObject3D) {
        // add in the usual parent-child way
        parentInstance.add(child);
        addedAsChild = true;
      }

      if (!addedAsChild) {
        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;
        // that is, anything that's a child in React but not a child in the scenegraph.
        parentInstance.__r3f.objects.push(child);
      }

      if (!child.__r3f) {
        prepare(child, {});
      }

      child.__r3f.parent = parentInstance;
      updateInstance(child);
      invalidateInstance(child);
    }
  }

  function insertBefore(parentInstance, child, beforeChild) {
    var added = false;

    if (child) {
      if (child.attachArray) {
        var array = parentInstance[child.attachArray];
        if (!is.arr(array)) parentInstance[child.attachArray] = [];
        array.splice(array.indexOf(beforeChild), 0, child);
      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {
        // attach and attachObject don't have an order anyway, so just append
        return appendChild(parentInstance, child);
      } else if (child.isObject3D && parentInstance.isObject3D) {
        child.parent = parentInstance;
        child.dispatchEvent({
          type: 'added'
        });
        var restSiblings = parentInstance.children.filter(function (sibling) {
          return sibling !== child;
        });
        var index = restSiblings.indexOf(beforeChild);
        parentInstance.children = [].concat(_toConsumableArray(restSiblings.slice(0, index)), [child], _toConsumableArray(restSiblings.slice(index)));
        added = true;
      }

      if (!added) {
        parentInstance.__r3f.objects.push(child);
      }

      if (!child.__r3f) {
        prepare(child, {});
      }

      child.__r3f.parent = parentInstance;
      updateInstance(child);
      invalidateInstance(child);
    }
  }

  function removeRecursive(array, parent) {
    var dispose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (array) _toConsumableArray(array).forEach(function (child) {
      return removeChild(parent, child, dispose);
    });
  }

  function removeChild(parentInstance, child, dispose) {
    if (child) {
      var _parentInstance$__r3f, _child$__r3f2;

      if (child.__r3f) {
        child.__r3f.parent = null;
      }

      if ((_parentInstance$__r3f = parentInstance.__r3f) != null && _parentInstance$__r3f.objects) {
        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(function (x) {
          return x !== child;
        });
      } // Remove attachment


      if (child.attachArray) {
        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(function (x) {
          return x !== child;
        });
      } else if (child.attachObject) {
        delete parentInstance[child.attachObject[0]][child.attachObject[1]];
      } else if (child.attach && !is.fun(child.attach) && parentInstance[child.attach] === child) {
        parentInstance[child.attach] = null;
      } else if (is.arr(child.attachFns)) {
        var _child$attachFns2 = _slicedToArray(child.attachFns, 2),
            detachFn = _child$attachFns2[1];

        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {
          parentInstance[detachFn](child);
        } else if (is.fun(detachFn)) {
          detachFn(child, parentInstance);
        }
      } else if (child.isObject3D && parentInstance.isObject3D) {
        var _child$__r3f;

        parentInstance.remove(child); // Remove interactivity

        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {
          removeInteractivity(child.__r3f.root, child);
        }
      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}
      // Never dispose of primitives because their state may be kept outside of React!
      // In order for an object to be able to dispose it has to have
      //   - a dispose method,
      //   - it cannot be a <primitive object={...} />
      //   - it cannot be a THREE.Scene, because three has broken it's own api
      //
      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined
      // when the reconciler calls it, but then carry our own check recursively


      var isPrimitive = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.primitive;
      var shouldDispose = dispose === undefined ? child.dispose !== null && !isPrimitive : dispose; // Remove nested child objects. Primitives should not have objects and children that are
      // attached to them declaratively ...

      if (!isPrimitive) {
        var _child$__r3f3;

        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);
        removeRecursive(child.children, child, shouldDispose);
      } // Remove references


      if (child.__r3f) {
        delete child.__r3f.root;
        delete child.__r3f.objects;
        delete child.__r3f.handlers;
        delete child.__r3f.memoizedProps;
        if (!isPrimitive) delete child.__r3f;
      } // Dispose item whenever the reconciler feels like it


      if (shouldDispose && child.dispose && child.type !== 'Scene') {
        unstable_runWithPriority(unstable_IdlePriority, function () {
          try {
            child.dispose();
          } catch (e) {
            /* ... */
          }
        });
      }

      invalidateInstance(parentInstance);
    }
  }

  function switchInstance(instance, type, newProps, fiber) {
    var _instance$__r3f6;

    var parent = (_instance$__r3f6 = instance.__r3f) == null ? void 0 : _instance$__r3f6.parent;
    if (!parent) return;
    var newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348
    // When args change the instance has to be re-constructed, which then
    // forces r3f to re-parent the children and non-scene objects
    // This can not include primitives, which should not have declarative children

    if (type !== 'primitive' && instance.children) {
      instance.children.forEach(function (child) {
        return appendChild(newInstance, child);
      });
      instance.children = [];
    }

    instance.__r3f.objects.forEach(function (child) {
      return appendChild(newInstance, child);
    });

    instance.__r3f.objects = [];
    removeChild(parent, instance);
    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node
    // https://github.com/facebook/react/issues/14983
    // https://github.com/facebook/react/pull/15021
    ;
    [fiber, fiber.alternate].forEach(function (fiber) {
      if (fiber !== null) {
        fiber.stateNode = newInstance;

        if (fiber.ref) {
          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;
        }
      }
    });
  }

  var reconciler = Reconciler({
    now: unstable_now,
    createInstance,
    removeChild,
    appendChild,
    appendInitialChild: appendChild,
    insertBefore,
    warnsIfNotActing: true,
    supportsMutation: true,
    isPrimaryRenderer: false,
    // @ts-ignore
    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,
    // @ts-ignore
    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,
    // @ts-ignore
    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,
    // @ts-ignore
    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,
    noTimeout: -1,
    appendChildToContainer: function appendChildToContainer(parentInstance, child) {
      var _getContainer = getContainer(parentInstance, child),
          container = _getContainer.container,
          root = _getContainer.root; // Link current root to the default scene


      container.__r3f.root = root;
      appendChild(container, child);
    },
    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
      return removeChild(getContainer(parentInstance, child).container, child);
    },
    insertInContainerBefore: function insertInContainerBefore(parentInstance, child, beforeChild) {
      return insertBefore(getContainer(parentInstance, child).container, child, beforeChild);
    },

    prepareUpdate(instance, type, oldProps, newProps) {
      if (instance.__r3f.primitive && newProps.object && newProps.object !== instance) return [true];else {
        // This is a data object, let's extract critical information about it
        var _newProps$args = newProps.args,
            argsNew = _newProps$args === void 0 ? [] : _newProps$args,
            cN = newProps.children,
            restNew = _objectWithoutProperties(newProps, _excluded4);

        var _oldProps$args = oldProps.args,
            argsOld = _oldProps$args === void 0 ? [] : _oldProps$args,
            cO = oldProps.children,
            restOld = _objectWithoutProperties(oldProps, _excluded5); // Throw if an object or literal was passed for args


        if (!Array.isArray(argsNew)) throw 'The args prop must be an array!'; // If it has new props or arguments, then it needs to be re-instanciated

        if (argsNew.some(function (value, index) {
          return value !== argsOld[index];
        })) return [true]; // Create a diff-set, flag if there are any changes

        var diff = diffProps(instance, restNew, restOld, true);
        if (diff.changes.length) return [false, diff]; // If instance was never attached, attach it

        if (instance.attach && typeof instance.attach !== 'function') {
          var localState = instance.__r3f;
          var parent = localState.parent;

          if (parent && parent[instance.attach] !== instance) {
            appendChild(parent, instance);
          }
        } // Otherwise do not touch the instance


        return null;
      }
    },

    commitUpdate(instance, _ref11, type, oldProps, newProps, fiber) {
      var _ref12 = _slicedToArray(_ref11, 2),
          reconstruct = _ref12[0],
          diff = _ref12[1];

      // Reconstruct when args or <primitive object={...} have changes
      if (reconstruct) switchInstance(instance, type, newProps, fiber); // Otherwise just overwrite props
      else applyProps(instance, diff);
    },

    hideInstance(instance) {
      if (instance.isObject3D) {
        instance.visible = false;
        invalidateInstance(instance);
      }
    },

    unhideInstance(instance, props) {
      if (instance.isObject3D && props.visible == null || props.visible) {
        instance.visible = true;
        invalidateInstance(instance);
      }
    },

    hideTextInstance() {
      throw new Error('Text is not allowed in the R3F tree.');
    },

    getPublicInstance(instance) {
      // TODO: might fix switchInstance (?)
      return instance;
    },

    getRootHostContext(rootContainer) {
      return EMPTY;
    },

    getChildHostContext(parentHostContext) {
      return parentHostContext;
    },

    createTextInstance() {},

    finalizeInitialChildren(instance) {
      var _instance$__r3f7; // https://github.com/facebook/react/issues/20271
      // Returning true will trigger commitMount


      var localState = (_instance$__r3f7 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f7 : {};
      return !!localState.handlers;
    },

    commitMount(instance)
    /*, type, props*/
    {
      var _instance$__r3f8; // https://github.com/facebook/react/issues/20271
      // This will make sure events are only added once to the central container


      var localState = (_instance$__r3f8 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f8 : {};
      if (instance.raycast && localState.handlers && localState.eventCount) instance.__r3f.root.getState().internal.interaction.push(instance);
    },

    shouldDeprioritizeSubtree() {
      return false;
    },

    prepareForCommit() {
      return null;
    },

    preparePortalMount(containerInfo) {
      prepare(containerInfo);
    },

    resetAfterCommit() {// noop
    },

    shouldSetTextContent() {
      return false;
    },

    clearContainer() {
      return false;
    }

  });
  return {
    reconciler,
    applyProps
  };
}

var isRenderer = function isRenderer(def) {
  return !!(def != null && def.render);
};

var isOrthographicCamera = function isOrthographicCamera(def) {
  return def && def.isOrthographicCamera;
};

function calculateDpr(dpr) {
  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;
}

var context = /*#__PURE__*/React.createContext(null);

var createStore = function createStore(applyProps, _invalidate, _advance, props) {
  var gl = props.gl,
      size = props.size,
      _props$shadows = props.shadows,
      shadows = _props$shadows === void 0 ? false : _props$shadows,
      _props$linear = props.linear,
      linear = _props$linear === void 0 ? false : _props$linear,
      _props$flat = props.flat,
      flat = _props$flat === void 0 ? false : _props$flat,
      _props$vr = props.vr,
      vr = _props$vr === void 0 ? false : _props$vr,
      _props$orthographic = props.orthographic,
      orthographic = _props$orthographic === void 0 ? false : _props$orthographic,
      _props$frameloop = props.frameloop,
      frameloop = _props$frameloop === void 0 ? 'always' : _props$frameloop,
      _props$dpr = props.dpr,
      dpr = _props$dpr === void 0 ? 1 : _props$dpr,
      performance = props.performance,
      _props$clock = props.clock,
      clock = _props$clock === void 0 ? new THREE.Clock() : _props$clock,
      raycastOptions = props.raycaster,
      cameraOptions = props.camera,
      onPointerMissed = props.onPointerMissed; // Set shadowmap

  if (shadows) {
    gl.shadowMap.enabled = true;
    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE.PCFSoftShadowMap;
  } // Set color preferences


  if (linear) gl.outputEncoding = THREE.LinearEncoding;
  if (flat) gl.toneMapping = THREE.NoToneMapping; // clock.elapsedTime is updated using advance(timestamp)

  if (frameloop === 'never') {
    clock.stop();
    clock.elapsedTime = 0;
  }

  var rootState = create(function (set, get) {
    // Create custom raycaster
    var raycaster = new THREE.Raycaster();

    var _ref13 = raycastOptions || {},
        params = _ref13.params,
        options = _objectWithoutProperties(_ref13, _excluded6);

    applyProps(raycaster, _objectSpread(_objectSpread({
      enabled: true
    }, options), {}, {
      params: _objectSpread(_objectSpread({}, raycaster.params), params)
    })); // Create default camera

    var isCamera = cameraOptions instanceof THREE.Camera;
    var camera = isCamera ? cameraOptions : orthographic ? new THREE.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE.PerspectiveCamera(75, 0, 0.1, 1000);

    if (!isCamera) {
      camera.position.z = 5;
      if (cameraOptions) applyProps(camera, cameraOptions); // Always look at center by default

      if (!(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);
    }

    var initialDpr = calculateDpr(dpr);
    var position = new THREE.Vector3();
    var defaultTarget = new THREE.Vector3();
    var tempTarget = new THREE.Vector3();

    function getCurrentViewport() {
      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : get().camera;
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTarget;
      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : get().size;
      var width = size.width,
          height = size.height;
      var aspect = width / height;
      if (target instanceof THREE.Vector3) tempTarget.copy(target);else tempTarget.set.apply(tempTarget, _toConsumableArray(target));
      var distance = camera.getWorldPosition(position).distanceTo(tempTarget);

      if (isOrthographicCamera(camera)) {
        return {
          width: width / camera.zoom,
          height: height / camera.zoom,
          factor: 1,
          distance,
          aspect
        };
      } else {
        var fov = camera.fov * Math.PI / 180; // convert vertical fov to radians

        var h = 2 * Math.tan(fov / 2) * distance; // visible height

        var w = h * (width / height);
        return {
          width: w,
          height: h,
          factor: width / w,
          distance,
          aspect
        };
      }
    }

    var performanceTimeout = undefined;

    var setPerformanceCurrent = function setPerformanceCurrent(current) {
      return set(function (state) {
        return {
          performance: _objectSpread(_objectSpread({}, state.performance), {}, {
            current
          })
        };
      });
    };

    return {
      gl,
      set,
      get,
      invalidate: function invalidate() {
        return _invalidate(get());
      },
      advance: function advance(timestamp, runGlobalEffects) {
        return _advance(timestamp, runGlobalEffects, get());
      },
      linear,
      flat,
      scene: prepare(new THREE.Scene()),
      camera,
      controls: null,
      raycaster,
      clock,
      mouse: new THREE.Vector2(),
      vr,
      frameloop,
      onPointerMissed,
      performance: _objectSpread(_objectSpread({
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200
      }, performance), {}, {
        regress: function regress() {
          var state = get(); // Clear timeout

          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance

          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile

          performanceTimeout = setTimeout(function () {
            return setPerformanceCurrent(get().performance.max);
          }, state.performance.debounce);
        }
      }),
      size: {
        width: 0,
        height: 0
      },
      viewport: {
        initialDpr,
        dpr: initialDpr,
        width: 0,
        height: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport
      },
      setSize: function setSize(width, height) {
        var size = {
          width,
          height
        };
        set(function (state) {
          return {
            size,
            viewport: _objectSpread(_objectSpread({}, state.viewport), getCurrentViewport(camera, defaultTarget, size))
          };
        });
      },
      setDpr: function setDpr(dpr) {
        return set(function (state) {
          return {
            viewport: _objectSpread(_objectSpread({}, state.viewport), {}, {
              dpr: calculateDpr(dpr)
            })
          };
        });
      },
      setFrameloop: function setFrameloop() {
        var frameloop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'always';
        return set(function () {
          return {
            frameloop
          };
        });
      },
      events: {
        connected: false
      },
      internal: {
        active: false,
        priority: 0,
        frames: 0,
        lastProps: props,
        lastEvent: /*#__PURE__*/React.createRef(),
        interaction: [],
        hovered: new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: new Map(),
        subscribe: function subscribe(ref) {
          var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          set(function (_ref14) {
            var internal = _ref14.internal;
            return {
              internal: _objectSpread(_objectSpread({}, internal), {}, {
                // If this subscription was given a priority, it takes rendering into its own hands
                // For that reason we switch off automatic rendering and increase the manual flag
                // As long as this flag is positive there can be no internal rendering at all
                // because there could be multiple render subscriptions
                priority: internal.priority + (priority > 0 ? 1 : 0),
                // Register subscriber and sort layers from lowest to highest, meaning,
                // highest priority renders last (on top of the other frames)
                subscribers: [].concat(_toConsumableArray(internal.subscribers), [{
                  ref,
                  priority
                }]).sort(function (a, b) {
                  return a.priority - b.priority;
                })
              })
            };
          });
          return function () {
            set(function (_ref15) {
              var internal = _ref15.internal;
              return {
                internal: _objectSpread(_objectSpread({}, internal), {}, {
                  // Decrease manual flag if this subscription had a priority
                  priority: internal.priority - (priority > 0 ? 1 : 0),
                  // Remove subscriber from list
                  subscribers: internal.subscribers.filter(function (s) {
                    return s.ref !== ref;
                  })
                })
              };
            });
          };
        }
      }
    };
  });
  var state = rootState.getState(); // Resize camera and renderer on changes to size and pixelratio

  var oldSize = state.size;
  var oldDpr = state.viewport.dpr;
  rootState.subscribe(function () {
    var _rootState$getState = rootState.getState(),
        camera = _rootState$getState.camera,
        size = _rootState$getState.size,
        viewport = _rootState$getState.viewport,
        internal = _rootState$getState.internal;

    if (size !== oldSize || viewport.dpr !== oldDpr) {
      // https://github.com/pmndrs/react-three-fiber/issues/92
      // Do not mess with the camera if it belongs to the user
      if (!camera.manual && !(internal.lastProps.camera instanceof THREE.Camera)) {
        if (isOrthographicCamera(camera)) {
          camera.left = size.width / -2;
          camera.right = size.width / 2;
          camera.top = size.height / 2;
          camera.bottom = size.height / -2;
        } else {
          camera.aspect = size.width / size.height;
        }

        camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178
        // Update matrix world since the renderer is a frame late

        camera.updateMatrixWorld();
      } // Update renderer


      gl.setPixelRatio(viewport.dpr);
      gl.setSize(size.width, size.height);
      oldSize = size;
      oldDpr = viewport.dpr;
    }
  }); // Update size

  if (size) state.setSize(size.width, size.height); // Invalidate on any change

  rootState.subscribe(function (state) {
    return _invalidate(state);
  }); // Return root state

  return rootState;
};

function createSubs(callback, subs) {
  var index = subs.length;
  subs.push(callback);
  return function () {
    return void subs.splice(index, 1);
  };
}

var i;
var globalEffects = [];
var globalAfterEffects = [];
var globalTailEffects = [];

var addEffect = function addEffect(callback) {
  return createSubs(callback, globalEffects);
};

var addAfterEffect = function addAfterEffect(callback) {
  return createSubs(callback, globalAfterEffects);
};

var addTail = function addTail(callback) {
  return createSubs(callback, globalTailEffects);
};

function run(effects, timestamp) {
  for (i = 0; i < effects.length; i++) {
    effects[i](timestamp);
  }
}

function render$1(timestamp, state) {
  // Run local effects
  var delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp

  if (state.frameloop === 'never' && typeof timestamp === 'number') {
    delta = timestamp - state.clock.elapsedTime;
    state.clock.oldTime = state.clock.elapsedTime;
    state.clock.elapsedTime = timestamp;
  } // Call subscribers (useFrame)


  for (i = 0; i < state.internal.subscribers.length; i++) {
    state.internal.subscribers[i].ref.current(state, delta);
  } // Render content


  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count

  state.internal.frames = Math.max(0, state.internal.frames - 1);
  return state.frameloop === 'always' ? 1 : state.internal.frames;
}

function createLoop(roots) {
  var running = false;
  var repeat;

  function loop(timestamp) {
    running = true;
    repeat = 0; // Run effects

    run(globalEffects, timestamp); // Render all roots

    roots.forEach(function (root) {
      var state = root.store.getState(); // If the frameloop is invalidated, do not run another frame

      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);
    }); // Run after-effects

    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop

    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops
    else run(globalTailEffects, timestamp); // Flag end of operation

    running = false;
  }

  function invalidate(state) {
    if (!state) return roots.forEach(function (root) {
      return invalidate(root.store.getState());
    });
    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60

    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it

    if (!running) {
      running = true;
      requestAnimationFrame(loop);
    }
  }

  function advance(timestamp) {
    var runGlobalEffects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var state = arguments.length > 2 ? arguments[2] : undefined;
    if (runGlobalEffects) run(globalEffects, timestamp);
    if (!state) roots.forEach(function (root) {
      return render$1(timestamp, root.store.getState());
    });else render$1(timestamp, state);
    if (runGlobalEffects) run(globalAfterEffects, timestamp);
  }

  return {
    loop,
    invalidate,
    advance
  };
}

function createPointerEvents(store) {
  var _createEvents = createEvents(store),
      handlePointer = _createEvents.handlePointer;

  var names = {
    onClick: ['click', false],
    onContextMenu: ['contextmenu', false],
    onDoubleClick: ['dblclick', false],
    onWheel: ['wheel', true],
    onPointerDown: ['pointerdown', true],
    onPointerUp: ['pointerup', true],
    onPointerLeave: ['pointerleave', true],
    onPointerMove: ['pointermove', true],
    onPointerCancel: ['pointercancel', true],
    onLostPointerCapture: ['lostpointercapture', true]
  };
  return {
    connected: false,
    handlers: Object.keys(names).reduce(function (acc, key) {
      return _objectSpread(_objectSpread({}, acc), {}, {
        [key]: handlePointer(key)
      });
    }, {}),
    connect: function connect(target) {
      var _events$handlers;

      var _store$getState8 = store.getState(),
          set = _store$getState8.set,
          events = _store$getState8.events;

      events.disconnect == null ? void 0 : events.disconnect();
      set(function (state) {
        return {
          events: _objectSpread(_objectSpread({}, state.events), {}, {
            connected: target
          })
        };
      });
      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(function (_ref16) {
        var _ref17 = _slicedToArray(_ref16, 2),
            name = _ref17[0],
            event = _ref17[1];

        var _names$name = _slicedToArray(names[name], 2),
            eventName = _names$name[0],
            passive = _names$name[1];

        target.addEventListener(eventName, event, {
          passive
        });
      });
    },
    disconnect: function disconnect() {
      var _store$getState9 = store.getState(),
          set = _store$getState9.set,
          events = _store$getState9.events;

      if (events.connected) {
        var _events$handlers2;

        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(function (_ref18) {
          var _ref19 = _slicedToArray(_ref18, 2),
              name = _ref19[0],
              event = _ref19[1];

          if (events && events.connected instanceof HTMLElement) {
            var _names$name2 = _slicedToArray(names[name], 1),
                eventName = _names$name2[0];

            events.connected.removeEventListener(eventName, event);
          }
        });
        set(function (state) {
          return {
            events: _objectSpread(_objectSpread({}, state.events), {}, {
              connected: false
            })
          };
        });
      }
    }
  };
} // React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser.


var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

function Block(_ref20) {
  var set = _ref20.set;
  useIsomorphicLayoutEffect(function () {
    set(new Promise(function () {
      return null;
    }));
    return function () {
      return set(false);
    };
  }, []);
  return null;
}

var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inherits(ErrorBoundary, _React$Component);

  var _super = _createSuper(ErrorBoundary);

  function ErrorBoundary() {
    var _this;

    _classCallCheck(this, ErrorBoundary);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      error: false
    };
    return _this;
  }

  _createClass(ErrorBoundary, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error) {
      this.props.set(error);
    }
  }, {
    key: "render",
    value: function render() {
      return this.state.error ? null : this.props.children;
    }
  }]);

  return ErrorBoundary;
}(React.Component);

ErrorBoundary.getDerivedStateFromError = function () {
  return {
    error: true
  };
};

var Canvas = /*#__PURE__*/React.forwardRef(function Canvas(_ref21, forwardedRef) {
  var children = _ref21.children,
      fallback = _ref21.fallback,
      tabIndex = _ref21.tabIndex,
      resize = _ref21.resize,
      id = _ref21.id,
      style = _ref21.style,
      className = _ref21.className,
      events = _ref21.events,
      props = _objectWithoutProperties(_ref21, _excluded7);

  var _useMeasure = useMeasure(_objectSpread({
    scroll: true,
    debounce: {
      scroll: 50,
      resize: 0
    }
  }, resize)),
      _useMeasure2 = _slicedToArray(_useMeasure, 2),
      containerRef = _useMeasure2[0],
      _useMeasure2$ = _useMeasure2[1],
      width = _useMeasure2$.width,
      height = _useMeasure2$.height;

  var canvasRef = React.useRef(null);

  var _React$useState = React.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      block = _React$useState2[0],
      setBlock = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      error = _React$useState4[0],
      setError = _React$useState4[1]; // Suspend this component if block is a promise (2nd run)


  if (block) throw block; // Throw exception outwards if anything within canvas throws

  if (error) throw error; // Execute JSX in the reconciler as a layout-effect

  useIsomorphicLayoutEffect(function () {
    if (width > 0 && height > 0) {
      render( /*#__PURE__*/React.createElement(ErrorBoundary, {
        set: setError
      }, /*#__PURE__*/React.createElement(React.Suspense, {
        fallback: /*#__PURE__*/React.createElement(Block, {
          set: setBlock
        })
      }, children)), canvasRef.current, _objectSpread(_objectSpread({}, props), {}, {
        size: {
          width,
          height
        },
        events: events || createPointerEvents
      }));
    }
  }, [width, height, children]);
  useIsomorphicLayoutEffect(function () {
    var container = canvasRef.current;
    return function () {
      return unmountComponentAtNode(container);
    };
  }, []);
  return /*#__PURE__*/React.createElement("div", {
    ref: containerRef,
    id: id,
    className: className,
    tabIndex: tabIndex,
    style: _objectSpread({
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden'
    }, style)
  }, /*#__PURE__*/React.createElement("canvas", {
    ref: mergeRefs([canvasRef, forwardedRef]),
    style: {
      display: 'block'
    }
  }, fallback));
});

function useStore() {
  var store = React.useContext(context);
  if (!store) throw "R3F hooks can only be used within the Canvas component!";
  return store;
}

function useThree() {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (state) {
    return state;
  };
  var equalityFn = arguments.length > 1 ? arguments[1] : undefined;
  return useStore()(selector, equalityFn);
}

function useFrame(callback) {
  var renderPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var subscribe = useStore().getState().internal.subscribe; // Update ref

  var ref = React.useRef(callback);
  React.useLayoutEffect(function () {
    return void (ref.current = callback);
  }, [callback]); // Subscribe on mount, unsubscribe on unmount

  React.useLayoutEffect(function () {
    return subscribe(ref, renderPriority);
  }, [renderPriority, subscribe]);
  return null;
}

function buildGraph(object) {
  var data = {
    nodes: {},
    materials: {}
  };

  if (object) {
    object.traverse(function (obj) {
      if (obj.name) {
        data.nodes[obj.name] = obj;
      }

      if (obj.material && !data.materials[obj.material.name]) {
        data.materials[obj.material.name] = obj.material;
      }
    });
  }

  return data;
}

function useGraph(object) {
  return React.useMemo(function () {
    return buildGraph(object);
  }, [object]);
}

function loadingFn(extensions, onProgress) {
  return function (Proto) {
    // Construct new loader and run extensions
    var loader = new Proto();
    if (extensions) extensions(loader); // Go through the urls and load them

    for (var _len2 = arguments.length, input = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      input[_key2 - 1] = arguments[_key2];
    }

    return Promise.all(input.map(function (input) {
      return new Promise(function (res, reject) {
        return loader.load(input, function (data) {
          if (data.scene) Object.assign(data, buildGraph(data.scene));
          res(data);
        }, onProgress, function (error) {
          return reject("Could not load ".concat(input, ": ").concat(error.message));
        });
      });
    }));
  };
}

function useLoader(Proto, input, extensions, onProgress) {
  // Use suspense to load async assets
  var keys = Array.isArray(input) ? input : [input];
  var results = useAsset.apply(void 0, [loadingFn(extensions, onProgress), Proto].concat(_toConsumableArray(keys))); // Return the object/s

  return Array.isArray(input) ? results : results[0];
}

useLoader.preload = function (Proto, input, extensions) {
  var keys = Array.isArray(input) ? input : [input];
  return useAsset.preload.apply(useAsset, [loadingFn(extensions), Proto].concat(_toConsumableArray(keys)));
};

useLoader.clear = function (Proto, input) {
  var keys = Array.isArray(input) ? input : [input];
  return useAsset.clear.apply(useAsset, [Proto].concat(_toConsumableArray(keys)));
};

var roots = new Map();
var modes = ['legacy', 'blocking', 'concurrent'];

var _createLoop = createLoop(roots),
    invalidate = _createLoop.invalidate,
    advance = _createLoop.advance;

var _createRenderer = createRenderer(),
    reconciler = _createRenderer.reconciler,
    applyProps = _createRenderer.applyProps;

var createRendererInstance = function createRendererInstance(gl, canvas) {
  var customRenderer = typeof gl === 'function' ? gl(canvas) : gl;
  if (isRenderer(customRenderer)) return customRenderer;
  var renderer = new THREE.WebGLRenderer(_objectSpread({
    powerPreference: 'high-performance',
    canvas: canvas,
    antialias: true,
    alpha: true
  }, gl)); // Set color management

  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping; // Set gl props

  if (gl) applyProps(renderer, gl);
  return renderer;
};

function render(element, canvas) {
  var _ref22 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      gl = _ref22.gl,
      size = _ref22.size,
      _ref22$mode = _ref22.mode,
      mode = _ref22$mode === void 0 ? modes[1] : _ref22$mode,
      events = _ref22.events,
      onCreated = _ref22.onCreated,
      props = _objectWithoutProperties(_ref22, _excluded8);

  var _store; // Allow size to take on container bounds initially


  if (!size) {
    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;

    size = {
      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,
      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0
    };
  }

  var root = roots.get(canvas);
  var fiber = root == null ? void 0 : root.fiber;
  var store = root == null ? void 0 : root.store;
  var state = (_store = store) == null ? void 0 : _store.getState();

  if (fiber && state) {
    // When a root was found, see if any fundamental props must be changed or exchanged
    // Check pixelratio
    if (props.dpr !== undefined && !is.equ(state.viewport.dpr, calculateDpr(props.dpr))) state.setDpr(props.dpr); // Check size

    if (state.size.width !== size.width || state.size.height !== size.height) state.setSize(size.width, size.height); // Check frameloop

    if (state.frameloop !== props.frameloop) state.setFrameloop(props.frameloop); // For some props we want to reset the entire root
    // Changes to the color-space

    var linearChanged = props.linear !== state.internal.lastProps.linear;

    if (linearChanged) {
      unmountComponentAtNode(canvas);
      fiber = undefined;
    }
  }

  if (!fiber) {
    // If no root has been found, make one
    // Create gl
    var glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested

    if (props.vr) {
      glRenderer.xr.enabled = true;
      glRenderer.setAnimationLoop(function (timestamp) {
        return advance(timestamp, true);
      });
    } // Create store


    store = createStore(applyProps, invalidate, advance, _objectSpread({
      gl: glRenderer,
      size
    }, props));

    var _state = store.getState(); // Create renderer


    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it

    roots.set(canvas, {
      fiber,
      store
    }); // Store events internally

    if (events) _state.set({
      events: events(store)
    });
  }

  if (store && fiber) {
    reconciler.updateContainer( /*#__PURE__*/React.createElement(Provider, {
      store: store,
      element: element,
      onCreated: onCreated,
      target: canvas
    }), fiber, null, function () {
      return undefined;
    });
    return store;
  } else {
    throw 'Error creating root!';
  }
}

function Provider(_ref23) {
  var store = _ref23.store,
      element = _ref23.element,
      onCreated = _ref23.onCreated,
      target = _ref23.target;
  React.useEffect(function () {
    var state = store.getState(); // Flag the canvas active, rendering will now begin

    state.set(function (state) {
      return {
        internal: _objectSpread(_objectSpread({}, state.internal), {}, {
          active: true
        })
      };
    }); // Connect events

    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered

    if (onCreated) onCreated(state);
  }, []);
  return /*#__PURE__*/React.createElement(context.Provider, {
    value: store
  }, element);
}

function unmountComponentAtNode(canvas, callback) {
  var root = roots.get(canvas);
  var fiber = root == null ? void 0 : root.fiber;

  if (fiber) {
    var state = root == null ? void 0 : root.store.getState();
    if (state) state.internal.active = false;
    reconciler.updateContainer(null, fiber, null, function () {
      if (state) {
        setTimeout(function () {
          var _state$gl, _state$gl$renderLists, _state$gl2;

          state.events.disconnect == null ? void 0 : state.events.disconnect();
          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();
          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();
          dispose(state);
          roots.delete(canvas);
          if (callback) callback(canvas);
        }, 500);
      }
    });
  }
}

function dispose(obj) {
  if (obj.dispose && obj.type !== 'Scene') obj.dispose();

  for (var p in obj) {
    var _dispose, _ref;

    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);
    delete obj[p];
  }
}

var act = reconciler.act;

function createPortal(children, container) {
  return reconciler.createPortal(children, container, null, null);
}

reconciler.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,
  rendererPackageName: '@react-three/fiber',
  version: '17.0.2'
});
export { Canvas, threeTypes as ReactThreeFiber, roots as _roots, act, addAfterEffect, addEffect, addTail, advance, applyProps, context, createPortal, dispose, createPointerEvents as events, extend, invalidate, reconciler, render, unmountComponentAtNode, useFrame, useGraph, useLoader, useStore, useThree };