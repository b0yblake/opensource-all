import { animate } from './index.mjs';
import { velocityPerSecond } from '../utils/velocity-per-second.mjs';
import { getFrameData } from 'framesync';

function inertia(_ref) {
  var _ref$from = _ref.from,
      from = _ref$from === void 0 ? 0 : _ref$from,
      _ref$velocity = _ref.velocity,
      velocity = _ref$velocity === void 0 ? 0 : _ref$velocity,
      min = _ref.min,
      max = _ref.max,
      _ref$power = _ref.power,
      power = _ref$power === void 0 ? 0.8 : _ref$power,
      _ref$timeConstant = _ref.timeConstant,
      timeConstant = _ref$timeConstant === void 0 ? 750 : _ref$timeConstant,
      _ref$bounceStiffness = _ref.bounceStiffness,
      bounceStiffness = _ref$bounceStiffness === void 0 ? 500 : _ref$bounceStiffness,
      _ref$bounceDamping = _ref.bounceDamping,
      bounceDamping = _ref$bounceDamping === void 0 ? 10 : _ref$bounceDamping,
      _ref$restDelta = _ref.restDelta,
      restDelta = _ref$restDelta === void 0 ? 1 : _ref$restDelta,
      modifyTarget = _ref.modifyTarget,
      driver = _ref.driver,
      _onUpdate = _ref.onUpdate,
      onComplete = _ref.onComplete,
      onStop = _ref.onStop;
  var currentAnimation;

  function isOutOfBounds(v) {
    return min !== undefined && v < min || max !== undefined && v > max;
  }

  function boundaryNearest(v) {
    if (min === undefined) return max;
    if (max === undefined) return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }

  function startAnimation(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: function onUpdate(v) {
        var _a;

        _onUpdate === null || _onUpdate === void 0 ? void 0 : _onUpdate(v);
        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);
      },
      onComplete,
      onStop
    }));
  }

  function startSpring(options) {
    startAnimation(Object.assign({
      type: "spring",
      stiffness: bounceStiffness,
      damping: bounceDamping,
      restDelta
    }, options));
  }

  if (isOutOfBounds(from)) {
    startSpring({
      from,
      velocity,
      to: boundaryNearest(from)
    });
  } else {
    var target = power * velocity + from;
    if (typeof modifyTarget !== "undefined") target = modifyTarget(target);
    var boundary = boundaryNearest(target);
    var heading = boundary === min ? -1 : 1;
    var prev;
    var current;

    var checkBoundary = function checkBoundary(v) {
      prev = current;
      current = v;
      velocity = velocityPerSecond(v - prev, getFrameData().delta);

      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {
        startSpring({
          from: v,
          to: boundary,
          velocity
        });
      }
    };

    startAnimation({
      type: "decay",
      from,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined
    });
  }

  return {
    stop: function stop() {
      return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    }
  };
}

export { inertia };