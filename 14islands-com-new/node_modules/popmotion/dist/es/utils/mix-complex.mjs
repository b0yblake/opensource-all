import _toConsumableArray from "/opt/build/repo/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js";
import { complex, color } from 'style-value-types';
import { mix } from './mix.mjs';
import { mixColor } from './mix-color.mjs';
import { isNum } from './inc.mjs';
import { pipe } from './pipe.mjs';
import { warning } from 'hey-listen';

function getMixer(origin, target) {
  if (isNum(origin)) {
    return function (v) {
      return mix(origin, target, v);
    };
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}

var mixArray = function mixArray(from, to) {
  var output = _toConsumableArray(from);

  var numValues = output.length;
  var blendValue = from.map(function (fromThis, i) {
    return getMixer(fromThis, to[i]);
  });
  return function (v) {
    for (var i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }

    return output;
  };
};

var mixObject = function mixObject(origin, target) {
  var output = Object.assign(Object.assign({}, origin), target);
  var blendValue = {};

  for (var key in output) {
    if (origin[key] !== undefined && target[key] !== undefined) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }

  return function (v) {
    for (var _key in blendValue) {
      output[_key] = blendValue[_key](v);
    }

    return output;
  };
};

function analyse(value) {
  var parsed = complex.parse(value);
  var numValues = parsed.length;
  var numNumbers = 0;
  var numRGB = 0;
  var numHSL = 0;

  for (var i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== undefined) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }

  return {
    parsed,
    numNumbers,
    numRGB,
    numHSL
  };
}

var mixComplex = function mixComplex(origin, target) {
  var template = complex.createTransformer(target);
  var originStats = analyse(origin);
  var targetStats = analyse(target);
  var canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;

  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning(true, "Complex values '".concat(origin, "' and '").concat(target, "' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition."));
    return function (p) {
      return "".concat(p > 0 ? target : origin);
    };
  }
};

export { mixArray, mixComplex, mixObject };